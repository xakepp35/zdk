# Спецификация ядра ZeroBus Run Kernel

```spec
File: spec/zrk.v1.ru.md
Owner: xakepp35
Version: v1.0.0
Updated: 2025-11-15
License: Apache 2.0
```

## 1. Область действия и цели

1.1. Настоящая спецификация определяет абстрактную модель **ZeroBus Run Kernel** — минимального ядра управления единицами работы (**run**) в системе ZeroBus.

1.2. Спецификация устанавливает:

* модель сущности **run** и её отношений;
* формальную модель состояний и кодов завершения;
* четыре ортогональных пространства исполнения (`space`);
* минимальный набор ABI-функций;
* требования к асинхронности, изоляции и детерминизму.

1.3. Спецификация не описывает:

* конкретные реализации планировщика, драйверов, хранилищ, индексов, протоколов;
* форматы бинарных данных, схем, профилей;
* реестр `KindId`, `StreamId`, `AlgoId`, `CursorId`, а также форматы управляющих потоков, воспринимаемых `host.ctrl`.

Все такие элементы считаются **опаковыми** и задаются над данной моделью.

---

## 2. Ядро модели

### 2.1. Run

2.1.1. **Run** — минимальная единица работы в системе.

2.1.2. Каждый run обладает:

* уникальным идентификатором `RunId`;
* необязательным идентификатором родителя `parent_run_id` (может быть специальным значением для корневых run-ов);
* состоянием `state`;
* кодом завершения `code`;
* четырьмя логическими контекстами исполнения по пространствам `space`.

2.1.3. В рамках настоящей спецификации **все свойства `RunId`, кроме уникальности, опаков**: формат, длина и алгоритм выдачи идентификаторов остаются на усмотрение реализации.

---

### 2.2. Пространства исполнения (`space`)

2.2.1. Модель определяет четыре ортогональных пространства исполнения:

```c
enum space {
    HOST = 1, // закрытое системное пространство ядра: железо, планировщик, драйверы
    EMIT = 2, // открытое ядро записи: логические события и свёртки состояния
    SCAN = 4, // открытое ядро чтения: запросы, сканирование, вычисления
    TASK = 8, // пользовательское пространство: прикладная логика (WASM/бинарь)
};
```

2.2.2. Для каждого `RunId` концептуально существует **ровно один** логический контекст в каждом из включённых пространств. Реализация может выделять физические структуры лениво, но логическое наличие контекста должно рассматриваться как данность.

2.2.3. Память и внутренние структуры контекстов различных пространств для одного и того же `RunId` должны быть изолированы. Прямой доступ к памяти одного пространства из другого запрещён. Взаимодействие между пространствами разрешено только через ABI-вызовы.

2.2.4. Набор реально используемых пространств для конкретного run-а задаётся при создании (`space_mask` в `task.init`). Обращение к ABI-функции, требующей пространство, не входящее в `space_mask` данного run-а, запрещено и должно трактоваться как логическая ошибка.

---

### 2.3. Состояния (`state`)

2.3.1. Каждый run в каждый момент времени находится ровно в одном из состояний:

```c
enum state {
    INIT = 0, // инициализация: контексты выделены и приведены к базовому состоянию, но не активны
    WAIT = 1, // ожидание: сформирован запрос, выполнены критерии готовности к запуску, ожидаются внешние условия
    EXEC = 2, // выполнение: run активно выполняет работу или выдаёт результат
    DONE = 3, // завершён: run финализирован, ресурсы подлежат освобождению
};
```

2.3.2. Переходы между состояниями ограничены **только соседними состояниями**:

* `INIT → WAIT`
* `WAIT → EXEC`
* `EXEC → WAIT`
* `EXEC → DONE`

Любые другие переходы состояний запрещены.

2.3.3. Переход `DONE → *` запрещён. После перевода run-а в `DONE` состояние становится неизменяемым.

2.3.4. `INIT` является единственным допустимым начальным состоянием только что созданного run-а. Создание run-а сразу в `WAIT`, `EXEC` или `DONE` настоящей спецификацией запрещено.

---

### 2.4. Коды завершения (`code`)

2.4.1. Код завершения run-а описывается перечислением:

```c
enum code {
    unset    = 0, // значение по умолчанию: run ещё не завершён или завершён успешно
    panic    = 1, // аварийное завершение из-за внутреннего сбоя реализации
    invalid  = 2, // логическая несостоятельность операции при данных входных условиях
    rejected = 3, // внешняя/физическая невозможность продолжать выполнение
};
```

2.4.2. Инварианты:

* Пока run находится в состояниях `INIT`, `WAIT` или `EXEC`, значение `code` обязано быть `unset`.
* При переходе run-а в состояние `DONE` его `code` обязан быть установлен в одно из значений перечисления и в дальнейшем не изменяться.
* Если `code == unset` в состоянии `DONE`, завершение run-а считается успешным.
* Значение `panic` должно использоваться только для сигнализации о дефекте реализации (нарушение инвариантов, некорректная работа среды выполнения).
* Значение `invalid` должно отражать невозможность продолжения выполнения по **логическим причинам** (предусловия, политики, формат, квоты, поддержка).
* Значение `rejected` должно отражать невозможность продолжения выполнения по **внешним или физическим причинам** (ресурсы, таймауты, внешняя отмена).

2.4.3. Спецификация не вводит отдельного понятия EOF. Любое успешное завершение, включая исчерпание данных при сканировании, представляется состоянием `DONE` при `code == unset`.

---

### 2.5. Контекст вызова ABI

2.5.1. Каждый ABI-вызов выполняется в контексте некоторого run-а и некоторого пространства:

* `caller_run_id` — идентификатор run-а, от имени которого выполняется вызов;
* `caller_space` — значение из `space`, соответствующее текущему пространству исполнения.

2.5.2. Вызов ABI, принимающий `run_id` в параметрах, должен явно различать:

* run, который является **контекстом вызова** (`caller_run_id`);
* run, к которому применяется действие (если параметр `run_id` указывает иной `RunId`).

2.5.3. Обращение к ABI с `run_id`, находящимся в состоянии `DONE`, запрещено и должно приводить к немедленному отказу (как минимум `invalid` либо, при нарушении инварианта реализации, `panic`).

---

### 2.6. Управляющий поток (`control-stream`)

2.6.1. Для каждого run-а логически существует **упорядоченный управляющий поток** (control-stream), ассоциированный с его контекстом исполнения.

2.6.2. Управляющий поток:

* принимает произвольные бинарные блоки управления;
* пополняется только через `host.ctrl`;
* доступен на чтение только из `TASK`-пространства того же `RunId` средствами реализации.

2.6.3. Формат и семантика содержимого управляющего потока (код, данные, сигналы) не задаются настоящей спецификацией и определяются на уровне надстроек над ядром.

---

## 3. Жизненный цикл run-а

### 3.1. Создание: `task.init`

3.1.1. Создание нового run-а допускается только через ABI-вызов:

```c
task.init(
    parent_run_id, // RunId родительского run-а или специальное значение для корневых run-ов
    kind_id,       // идентификатор типа запускаемого кода (KindId)
    space_mask,    // битовая маска пространств: подмножество {HOST, EMIT, SCAN, TASK}
    params_blob,   // опаковый бинарный блок параметров и конфигурации
    out_run_id     // выходной параметр для нового RunId
) -> code;
```

3.1.2. При успешном выполнении `task.init` обязано выполняться следующее:

* создаётся новый `RunId`;
* создаются и инициализируются логические контексты для всех пространств, присутствующих в `space_mask`;
* инициализируется пустой управляющий поток, ассоциированный с `RunId`;
* `state` нового run-а устанавливается в `INIT`;
* `code` нового run-а устанавливается в `unset`;
* в `out_run_id` возвращается созданный `RunId`;
* результат вызова — `code == unset`.

3.1.3. Настоящая спецификация не накладывает требований на содержимое пользовательского кода в `TASK`-пространстве при создании run-а; в базовой модели предполагается, что пользовательская логика не задана и может быть загружена позднее через управляющий поток.

3.1.4. При ошибке `task.init` должно возвращать один из кодов `panic`, `invalid` или `rejected`. В этом случае:

* новый run не должен считаться созданным с точки зрения внешних наблюдателей;
* значение `out_run_id` считается неопределённым и не должно использоваться.

3.1.5. Создание run-а иным способом, кроме `task.init`, запрещено.

---

### 3.2. Завершение: `task.done`

3.2.1. Корректное завершение run-а должно выполняться вызовом:

```c
task.done(
    run_id,     // идентификатор завершаемого run-а
    final_code  // итоговый код завершения: unset / panic / invalid / rejected
);
```

3.2.2. При корректном вызове `task.done` реализация обязана:

* проверить, что run находится в состоянии `EXEC` или `WAIT`;
* перевести run в состояние `DONE`;
* установить `code` в значение `final_code`;
* инициировать освобождение ресурсов run-а согласно внутренней политике;
* запретить дальнейшую запись в управляющий поток данного run-а: последующие вызовы `host.ctrl` с этим `run_id` должны завершаться с ошибкой.

3.2.3. Повторный вызов `task.done` для одного и того же `run_id` запрещён.

3.2.4. Завершение run-а без вызова `task.done` допускается только в случае фатального сбоя на уровне реализации. В таком случае run должен быть переведён в `DONE` с кодом `panic`.

---

### 3.3. Допустимая эволюция run-а

3.3.1. Каждый run после создания обязан пройти последовательность состояний, удовлетворяющую:

* начальное состояние: `INIT`;
* далее — конечное состояние: `DONE`;
* промежуточные переходы подчинены правилу соседних состояний (§2.3.2).

3.3.2. Переводы `INIT → WAIT`, `WAIT → EXEC`, `EXEC → WAIT` и `EXEC → DONE` могут инициироваться выполнением ABI-вызовов и внутренней логикой планировщика, но во всех случаях должны строго соблюдать указанную последовательность.

---

## 4. Поверхность ABI

### 4.1. TASK-плоскость

4.1.1. TASK-плоскость обеспечивает:

* создание run-ов (`task.init`);
* завершение run-ов (`task.done`).

4.1.2. TASK-плоскость не должна напрямую модифицировать состояние или планирование других run-ов кроме как через явно определённые ABI-вызовы.

---

### 4.2. HOST-плоскость

#### 4.2.1. Управляющий поток: `host.ctrl`

```c
host.ctrl(
    target_run_id, // RunId, чей управляющий поток пополняется
    ctrl_blob      // бинарный блок управляющих данных/инструкций
) -> code;
```

4.2.1.1. `host.ctrl` представляет собой абстракцию операций control-plane над run-ами и их окружением через пополнение их управляющих потоков.

4.2.1.2. Вызов `host.ctrl` должен интерпретироваться реализацией как атомарная попытка добавить `ctrl_blob` в конец управляющего потока `target_run_id`. При успешной записи допускается инициировать перевод соответствующего run-а из `WAIT` в `EXEC` согласно внутренней политике планировщика.

4.2.1.3. Формат и семантика `ctrl_blob` являются опаковыми для ядра и определяются над данной спецификацией. Ядро не обязано понимать содержимое управляющего потока и обеспечивает лишь доставку и упорядочивание блоков.

4.2.1.4. Вызов `host.ctrl` для `target_run_id`, находящегося в состоянии `DONE`, запрещён и должен завершаться с ошибкой (как минимум `invalid` или `rejected`), без изменения управляющего потока.

4.2.1.5. Реализация может вводить дополнительные ограничения на права вызова `host.ctrl`. В базовой модели корректным считается вызов, инициированный:

* либо из `HOST`-пространства;
* либо из run-а, являющегося родительским для `target_run_id` (по `parent_run_id`).

---

#### 4.2.2. Ожидание и пробуждение: `host.sync`

```c
host.sync(
    current_run_id, // RunId текущего run-а
    wait_flags,     // опаковый набор условий ожидания
    timeout_ns      // дедлайн ожидания в наносекундах (0 — отсутствие дедлайна)
) -> code;
```

4.2.2.1. `host.sync` является единственным системным механизмом перевода run-а в состояние ожидания.

4.2.2.2. При корректном вызове из состояния `EXEC` реализация обязана:

* перевести run в состояние `WAIT`;
* зарегистрировать условия пробуждения согласно `wait_flags` и `timeout_ns`.

4.2.2.3. После наступления условий пробуждения планировщик обязан:

* либо перевести run в очередь исполнения (возможен переход из `WAIT` в `EXEC` в рамках цикла планирования),
* либо завершить run с кодом `rejected` и состоянием `DONE`, если условия выполнения задач более не могут быть выполнены (например, при критическом таймауте).

4.2.2.4. Любое “блокирующее” ожидание, реализованное без использования `host.sync`, считается нарушением спецификации.

---

### 4.3. EMIT-плоскость

4.3.1. EMIT-плоскость обеспечивает абстрактные операции модификации логического состояния:

```c
emit.commit(
    run_id,
    stream_id,   // идентификатор логического потока/журнала
    event_blob,  // бинарное представление события
    out_pos      // логическая позиция записи
) -> code;
```

4.3.1.1. `emit.commit` является единственной абстрактной операцией записи события в логический поток. Поведение при повторных вызовах с идентичными параметрами должно быть детерминированным.

---

```c
emit.reduce(
    run_id,
    algo_id,     // идентификатор алгоритмической модели
    in_state,
    in_event,
    out_state
) -> code;
```

4.3.2.1. `emit.reduce` описывает детерминированное применение события к состоянию алгоритмической модели. Конкретный формат и семантика `algo_id`, `in_state` и `in_event` определяются над данной спецификацией.

---

```c
emit.converge(
    run_id,
    algo_id,
    left_state,
    right_state,
    out_state
) -> code;
```

4.3.3.1. `emit.converge` описывает детерминированное слияние двух состояний алгоритмической модели. Требования к алгебраическим свойствам (ассоциативность, коммутативность, идемпотентность) задаются на уровне конкретных алгоритмов.

---

4.3.4. Операции EMIT-плоскости не должны выполнять долговременное блокирующее ожидание. При необходимости ожидания внешних условий они должны инициировать переход run-а в `WAIT` через механизмы HOST-плоскости.

---

### 4.4. SCAN-плоскость

4.4.1. SCAN-плоскость обеспечивает операции чтения, сканирования и получения снимков состояния.

```c
scan.next(
    run_id,
    cursor_id,   // идентификатор логического курсора
    params_blob  // параметры шага сканирования
) -> code;
```

4.4.1.1. `scan.next` инициализирует или продвигает логический курсор. Конкретные значения `cursor_id` и структура `params_blob` задаются над данной спецификацией.

---

```c
scan.read(
    run_id,
    cursor_id,
    out_item     // размещение результата
) -> code;
```

4.4.2.1. `scan.read` возвращает очередной элемент, подготовленный предыдущими вызовами `scan.next` и возможными операциями планировщика.

4.4.2.2. Вызов `scan.read` не должен сам инициировать долговременные операции ожидания. Необходимое ожидание должно быть реализовано через переход run-а в `WAIT` при помощи `host.sync`.

---

```c
scan.seal(
    run_id,
    view_id,     // идентификатор логического представления состояния
    params_blob, // параметры формирования снимка
    out_snapshot // бинарный снимок
) -> code;
```

4.4.3.1. `scan.seal` описывает получение детерминированного снимка состояния для заданного логического представления.

4.4.3.2. `scan.seal` не должен модифицировать логическое состояние системы. Персистентное сохранение полученного снимка за пределами текущего run-а должно выполняться через EMIT-плоскость.

---

## 5. Асинхронность и изоляция

5.1. Ядро должно обеспечивать возможность одновременного существования и выполнения множества run-ов без взаимного неконтролируемого влияния.

5.2. Ошибка `panic` в одном run-е не должна автоматически нарушать корректность других run-ов. Реализация может переводить зависимые run-ы в `DONE` с `rejected` или иным кодом, согласованным с внутренней политикой, но обязана сохранять инварианты состояний и кодов завершения.

5.3. Любая операция, требующая ожидания внешних условий, обязана оформляться переходом run-а в состояние `WAIT` через `host.sync`.

5.4. Внутри EMIT- и SCAN-плоскостей разрешаются только те побочные эффекты, которые соответствуют их назначению:

* EMIT — модификация логического состояния;
* SCAN — чтение и формирование представлений состояния.

5.5. TASK-плоскость не должна получать прямой доступ к физическим ресурсам (железо, системные драйверы) в обход HOST-плоскости.

---

## 6. Глобальные инварианты модели

6.1. **Единая точка создания run-а**: любой наблюдаемый run создаётся только через `task.init`.

6.2. **Единая точка завершения run-а**: корректное завершение run-а производится через `task.done`. Любое иное завершение должно быть представлено как эквивалент домена `panic`.

6.3. **Единая машина состояний**: run всегда находится ровно в одном состоянии из `INIT`, `WAIT`, `EXEC`, `DONE`; переходы допускаются только между соседними состояниями, а `DONE` является терминальным.

6.4. **Единый критерий успешного завершения**: успешным считается только состояние `DONE` при `code == unset`. Дополнительные состояния (EOF и подобные) ядром не вводятся.

6.5. **Разделение пространств**: HOST, EMIT, SCAN, TASK имеют раздельные контексты, связанные только через ABI-вызовы и идентификаторы; прямой доступ к памяти поперёк пространств запрещён.

6.6. **Детерминированность поведения EMIT/SCAN**: при фиксированных входных данных, идентификаторах и конфигурации реализация EMIT- и SCAN-плоскостей должна обеспечивать воспроизводимое поведение.

6.7. **Расширяемость без нарушения ядра**: добавление новых типов run-ов (`KindId`), потоков (`StreamId`), алгоритмов (`AlgoId`), курсоров (`CursorId`) и протоколов управления (форматов управляющих потоков `host.ctrl`) допускается без изменения данной спецификации при условии соблюдения всех перечисленных инвариантов.

---

### 7. Формальное доказательство

В этом разделе показано, что заданная модель ядра:

* внутренне непротиворечива (consistency),
* сохраняет заявленные инварианты (safety),
* обеспечивает асинхронность и изоляцию,
* минимальна относительно поставленных целей (minimality).

Доказательство ведётся в терминах абстрактного автомата переходов.

---

#### 7.1. Конфигурации и переходы

**Определение 7.1 (Run).**
Run — четвёрка
[
r = \langle \text{run_id}, \text{state}, \text{code}, \text{spaces} \rangle
]
где:

* `run_id` — уникальный идентификатор;
* `state ∈ {INIT, WAIT, EXEC, DONE}`;
* `code ∈ {unset, panic, invalid, rejected}`;
* `spaces ⊆ {HOST, EMIT, SCAN, TASK}` — подмножество пространств, заданное при `task.init`.

**Определение 7.2 (Конфигурация системы).**
Конфигурация системы
[
C = \langle R \rangle
]
где `R` — конечное множество run-ов.
Требуется, чтобы `run_id` у элементов `R` были попарно различны.

**Определение 7.3 (Начальная конфигурация).**
Начальная конфигурация `C₀` содержит пустое множество run-ов:
[
C_0 = \langle \varnothing \rangle
]

**Определение 7.4 (Переход).**
Переходом называется пара конфигураций
[
C \xrightarrow{\alpha} C'
]
где метка `α` соответствует одному корректному ABI-вызову (`task.init`, `task.done`, `host.ctrl`, `host.sync`, `emit.*`, `scan.*`) при заданном `caller_run_id` и `caller_space`.

Семантика `α` задаётся спецификацией §3–§4 и инвариантами §5–§6; в данном разделе мы используем только следствия, явно сформулированные там:

1. `task.init` добавляет в `R` новый run в состоянии `INIT` с `code = unset`.
2. `task.done` переводит существующий run из `WAIT` или `EXEC` в `DONE` и устанавливает его `code`.
3. `host.sync` переводит текущий run из `EXEC` в `WAIT`.
4. Любой другой ABI-вызов может переводить run из `WAIT` в `EXEC` или из `EXEC` в `WAIT`, но не в другие состояния.
5. Ни один ABI-вызов не переводит run из `DONE` в иное состояние.
6. Ни один ABI-вызов, кроме `task.init`, не создаёт новых run-ов.
7. Ни один ABI-вызов, кроме `task.done` и фатального сбоя (модель `panic`), не завершает run (не устанавливает `state = DONE` и не задаёт финальный `code`).

---

#### 7.2. Инвариант 1: корректность состояний и кодов

**Формулировка.**
Для любой конфигурации `C`, достижимой из `C₀` конечной последовательностью переходов, выполняются свойства:

1. Для любого run-а `r ∈ R(C)`:

   * `state(r) ∈ {INIT, WAIT, EXEC, DONE}`;
   * если `state(r) ≠ DONE`, то `code(r) = unset`;
   * если `state(r) = DONE`, то `code(r) ∈ {unset, panic, invalid, rejected}`.
2. Переходы `state` между конфигурациями соответствуют только последовательности соседних состояний:

   * `INIT → WAIT`,
   * `WAIT → EXEC`,
   * `EXEC → WAIT`,
   * `EXEC → DONE`.

**Доказательство (по индукции по длине пути).**

*База.*
В начальной конфигурации `C₀` множество run-ов пусто, инвариант выполняется тривиально.

*Шаг.*
Предположим, что инвариант выполняется в конфигурации `C`. Рассмотрим переход
[
C \xrightarrow{\alpha} C'
]

Разбираем по случаям `α`:

1. **`task.init`.**
   По спецификации:

   * создаётся новый run `r_new` с:

     * `state = INIT`,
     * `code = unset`,
     * `spaces ⊆ {HOST, EMIT, SCAN, TASK}`.
   * остальные run-ы не меняют `state` и `code`.

   Следовательно, все состояния и коды остаются в допустимых множествах, а новый run удовлетворяет требованиям. Переход состояния для нового run-а отсутствует (начальное значение `INIT`), для остальных run-ов — не происходит.

2. **`task.done`.**
   По спецификации:

   * целевой run должен находиться в состоянии `WAIT` или `EXEC`;
   * он переводится в состояние `DONE`;
   * его `code` устанавливается в одно из значений `{unset, panic, invalid, rejected}`;
   * другие run-ы не затрагиваются.

   Это соответствует допустимому переходу `WAIT → DONE` или `EXEC → DONE`. Поскольку другие переходы запретены, инвариант сохраняется.

3. **`host.sync`.**
   По спецификации:

   * вызывается из состояния `EXEC`;
   * переводит текущий run в состояние `WAIT`.

   Это соответствует допустимому переходу `EXEC → WAIT`. `code` при этом не изменяется и, по предположению индукции, равен `unset` (так как run не в `DONE`). Инвариант сохраняется.

4. **Другие ABI-вызовы.**
   Для остальных операций спецификация явно разрешает только переходы `WAIT → EXEC` и `EXEC → WAIT` (по внутренней логике планировщика и обработки запросов). Другие переходы (например, `INIT → EXEC` или `DONE → *`) запрещены.

   Поскольку по предположению индукции `state` находится в допустимом значении и переходы строго ограничены соседними, инвариант по состояниям сохраняется. Код `code` при этом для незавершённых run-ов остаётся `unset`.

Таким образом, для любой достижимой конфигурации `C'` инвариант выполняется. По индукции утверждение доказано. ∎

---

#### 7.3. Инвариант 2: единственность создания и завершения run-а

**Формулировка.**

1. Каждый `RunId` появляется в системе не более одного раза.
2. Для каждого `RunId` существует не более одного корректного вызова `task.done`.

**Доказательство.**

1. По §3.1.5 создание run-а допускается только через `task.init`.
   Спецификация требует, чтобы при успешном `task.init` создавался новый `RunId`, не совпадающий с уже существующими (`RunId` — уникален внутри множества run-ов конфигурации). Таким образом, один и тот же `RunId` не может быть порождён повторно без нарушения спецификации.

2. По §3.2.3 повторный вызов `task.done` для одного и того же `run_id` запрещён.
   Поскольку единственный разрешённый способ завершения run-а — `task.done`, а повторные вызовы считаются некорректными, для каждого `RunId` существует не более одного корректного завершения.

Следовательно, жизненный цикл каждого run-а однократно ограничен созданием через `task.init` и завершением через `task.done`. ∎

---

#### 7.4. Инвариант 3: терминальность состояния DONE

**Формулировка.**
Для любого run-а `r` и любых двух достижимых конфигураций `C` и `C'`, таких что в `C` выполняется `state(r) = DONE`, во всех последующих конфигурациях `C'` также выполняется `state(r) = DONE` и `code(r)` неизменен.

**Доказательство.**

Из §2.3.2 и §2.3.3 следует, что:

* единственный допустимый переход из состояния, отличного от `DONE`, — это переход в соседнее состояние;
* переход `DONE → *` прямо запрещён.

Ни одна из ABI-функций в §4 не описывает изменение состояния run-а из `DONE` в иное состояние; напротив, §3.2.3 фиксирует, что `task.done` может вызываться только для run-а, не находящегося в `DONE`. Следовательно, никакой корректный переход из `DONE` невозможен.

Аналогично, ни одна ABI-функция не допускает изменения `code` для run-а после перевода в `DONE`. Таким образом, как состояние, так и код завершения остаются неизменными во всех последующих конфигурациях. ∎

---

#### 7.5. Инвариант 4: изоляция пространств

**Формулировка.**
Ни один корректный ABI-вызов не предоставляет прямого доступа к памяти или внутреннему состоянию другого пространства `space` для данного `RunId` (или другого `RunId`) за пределами явно описанных параметров и результатов вызова.

**Доказательство.**

Из §2.2.3 следует, что:

* контексты `HOST`, `EMIT`, `SCAN`, `TASK` для данного run-а изолированы;
* взаимодействие между ними должно происходить исключительно через ABI-вызовы.

В §4 все ABI-функции формально заданы с параметрами вида:

* идентификаторы (`run_id`, `stream_id`, `algo_id`, `cursor_id`, `view_id`);
* бинарные блоки (`params_blob`, `event_blob`, `ctrl_blob`, `out_snapshot`, `out_item`);
* простые выходные значения (позиция, код, `RunId`).

Ни одна из функций не предоставляет интерфейс чтения или записи произвольных участков памяти другого пространства, поскольку:

* внутренние структуры этих пространств не экспонируются в сигнатурах;
* любые данные передаются в сериализованной форме (бинарные блоки), интерпретация которых не зависит от непосредственной адресации памяти.

Таким образом, при соблюдении спецификации реализация может организовать внутреннее хранение контекстов пространств любым образом, включая физическую изоляцию, и никакой ABI-вызов не нарушает это свойство. ∎

---

#### 7.6. Инвариант 5: асинхронность и отсутствие глобальных блокировок

**Формулировка.**

1. Любое ожидание внешних условий для run-а должно оформляться переходом `EXEC → WAIT` через `host.sync`.
2. Никакой ABI-вызов не должен создавать глобальную блокировку, препятствующую выполнению других run-ов.

**Доказательство.**

1. §4.2.2.4 прямо устанавливает, что любое блокирующее ожидание, реализованное без `host.sync`, считается нарушением спецификации. Следовательно, корректная реализация обязана реализовывать ожидание только через переход `EXEC → WAIT` посредством `host.sync`.

2. Поскольку перевод одного run-а в `WAIT` не накладывает требований на состояние других run-ов, реализация планировщика может продолжать исполнять другие run-ы, находящиеся в `EXEC` или готовые к переходу из `WAIT` в `EXEC`. Спецификация нигде не требует приостановки всех run-ов при ожидании одного из них.

Так как глобальных ресурсов, требующих единоличного владения всеми run-ами, в ABI не описано, соблюдение данной спецификации гарантирует возможность реализации без глобальных блокировок, влияющих на всю систему целиком. ∎

---

#### 7.7. Минимальность интерфейса

**Формулировка.**
Множество ABI-функций, описанных в §4, является минимальным (в смысле функций ядра), необходимым для выполнения следующих требований:

1. создание и завершение run-ов;
2. управление планированием и ожиданием;
3. модификация логического состояния;
4. чтение логического состояния и формирование снимков;
5. управление run-ами через их управляющие потоки.

Устранение любого из классов функций (`task`, `host`, `emit`, `scan`) приводит к невозможности удовлетворить одну из указанных групп требований без нарушения инвариантов §6.

**Доказательство (эскиз).**

Рассмотрим четыре группы:

1. **TASK (`task.init`, `task.done`).**
   Удаление `task.init` лишает систему единственного механизма создания run-ов (§3.1.5), что делает невозможным существование динамических единиц работы. Попытка перенести создание в другие ABI-вызовы нарушит инвариант единственности источника run-ов (§6.1).
   Удаление `task.done` лишает систему единственного корректного способа завершать run, нарушая §6.2.

2. **HOST (`host.ctrl`, `host.sync`).**
   Удаление `host.sync` лишает систему формального механизма перевода run-а в состояние ожидания, что либо нарушает инвариант состояний (§2.3), либо вынуждает реализовывать блокирующие вызовы, запрещённые §4.2.2.4 и §5.3.
   Удаление `host.ctrl` лишает систему единого механизма пополнения управляющих потоков run-ов и отделения control-plane от data-plane, что делает невозможным локализованное управление `RunId` без нарушения изоляции и согласованности (§5.5, §6.5).

3. **EMIT (`emit.commit`, `emit.reduce`, `emit.converge`).**
   Удаление `emit.commit` лишает систему абстрактной точки входа для логических событий, что делает невозможным формализованную модификацию состояния.
   Удаление `emit.reduce` и `emit.converge` делает невозможным абстрактное описание эволюции состояний и их слияния в ядре и вынуждает переносить эту функциональность в TASK или HOST, нарушая разделение обязанностей (§6.5).

4. **SCAN (`scan.next`, `scan.read`, `scan.seal`).**
   Удаление `scan.next` и `scan.read` лишает систему формального механизма сканирования и чтения состояния, что делает невозможным реализацию query-плоскости без нарушения CQRS-отделения чтения от записи.
   Удаление `scan.seal` лишает ядро единого абстрактного механизма получения снимков состояния, необходимого для реплея, переносимости и экспорта, и вынуждает реализовывать такую функциональность внутри EMIT или TASK, нарушая их инварианты (EMIT — только модификация, TASK — только оркестрация).

Поскольку для каждой из четырёх групп функций существует требование, которое не может быть удовлетворено без них, и поскольку переназначение этих функций на другие плоскости приводит к нарушению хотя бы одного глобального инварианта §6, множество функций §4 является минимальным в смысле ядра. ∎

---

В совокупности теоремы 7.2–7.7 показывают, что:

* модель состояний и кодов завершения непротиворечива и замкнута;
* жизненный цикл run-а однозначно определён и конечен;
* пространства исполнения изолированы и взаимодействуют только через ABI;
* асинхронность и отсутствие глобальных блокировок могут быть реализованы без противоречия спецификации;
* интерфейс ядра минимален и достаточен для построения более сложных примитивов и алгоритмов поверх него.

Этим завершается формальное обоснование корректности и достаточности модели ZeroBus Run Kernel v1.
