# Спецификация ядра ZeroBus Run Kernel

```spec
File:    spec/zrk.v1.ru.md
Owner:   xakepp35
Version: v1.3.0
Updated: 2025-11-20
License: Apache 2.0
```

# 1. Область действия и цели

1.1. Настоящая спецификация определяет абстрактную модель **ZeroBus Task Kernel (ZRK)** — минимального ядра управления единицами работы (**task**) и их алгоритмами (`AlgoId`) в системе ZeroBus.

1.2. Спецификация устанавливает:

* модель сущности **task** и её атрибутов;
* формальную модель состояний и кодов завершения;
* модель ресурсов исполнения (время, вычисления, память, вызовы, байты);
* модель глобальных идентификаторов задач/алгоритмов (`TaskId`) и локальных слотов (`SlotId`);
* минимальный набор ABI-функций:
  * для тестов `noop`;
  * для глобальных алгоритмов (EMIT-плоскость): `init`, `emit`, `done`;
  * для локальных сканеров и данных (SCAN/LOCAL-плоскость): `slot`, `scan`, `next`, `read`;
* требования к асинхронности, изоляции и детерминизму.

1.3. Спецификация **не описывает**:

* конкретные реализации планировщиков, драйверов, хранилищ, индексов, протоколов;
* форматы бинарных данных, схем, профилей и конфигураций алгоритмов;
* реестры `AlgoId` и сопоставление `AlgoId → класс/семейство/профиль`;
* агрегирование ресурсов по `grant_id`, `task_id` или их комбинациям;
* внутреннюю семантику задач-грантов и политику безопасности (GrantForge/ZBAC);
* внутренний формат содержимого локальных слотов.

Все такие элементы считаются **опаковыми** и задаются над данной моделью (ZDK, GrantForge/ZBAC и др.).

---

# 2. Ядро модели

## 2.1. Task

2.1.1. **Task** — минимальная единица работы в системе и одновременно глобальный идентификатор состояния алгоритма.

2.1.2. Каждая task описывается кортежем:

```text
Task = {
    task_id:   TaskId;     // уникальный идентификатор задачи и её глобального состояния
    parent_id: TaskId?;    // необязательный идентификатор родительской задачи
    algo_id:   AlgoId;     // идентификатор алгоритма, исполняемого задачей
    grant_id:  TaskId?;    // идентификатор задачи-гранта, от имени которой выполняется задача
    state:     state;      // текущее состояние
    code:      code;       // код завершения
    resources: Resources;  // ресурсные счётчики задачи
}
```

2.1.3. `TaskId` и `AlgoId` являются **опаковыми**:

* ZRK требует только уникальности `TaskId` в пространстве живых задач;
* интерпретация `AlgoId` определяется надстройками (ZDK, профили и др.).

2.1.4. Поле `grant_id: TaskId?`:

* трактуется как опциональная ссылка на **задачу-грант** (особый вид task на уровне надстроек);
* ZRK не навязывает семантику задач-грантов, но допускает использование `grant_id` для:

  * агрегирования ресурсов;
  * принятия решений по безопасности;
  * учёта “от имени кого” выполняется текущая task.

2.1.5. ZRK не интерпретирует `parent_id`. Семантика и использование иерархий задач (родитель/потомок) задаются на уровне узла/планировщика. Рекомендуется устанавливать `parent_id` новой задачи в `current_task_id` инициатора вызова `init`, либо в специальное “нулевое” значение при системном создании.

---

## 2.2. Состояния (`state`)

2.2.1. Каждая task в каждый момент времени находится ровно в одном из состояний:

```c
enum state {
    INIT = 0, // инициализация: создана, но ещё не запущена
    WAIT = 1, // ожидание: приостановлена, ждёт внешних условий
    EXEC = 2, // выполнение: активно исполняет код
    DONE = 3, // завершена: финализирована, ресурсы подлежат освобождению
};
```

2.2.2. Переходы между состояниями ограничены **только соседними состояниями**:

* `INIT → WAIT`
* `WAIT → EXEC`
* `EXEC → WAIT`
* `EXEC → DONE`

Любые другие переходы состояний запрещены.

2.2.3. Переход `DONE → *` запрещён. После перевода task в `DONE` её состояние становится неизменяемым.

2.2.4. `INIT` является единственным допустимым начальным состоянием только что созданной задачи. Создание task сразу в `WAIT`, `EXEC` или `DONE` настоящей спецификацией запрещено.

---

## 2.3. Коды завершения (`code`)

2.3.1. Код завершения task описывается перечислением:

```c
enum code {
    unset    = 0, // значение по умолчанию: задача не завершена либо завершена успешно
    panic    = 1, // аварийное завершение из-за внутреннего сбоя реализации
    invalid  = 2, // логическая несостоятельность операции при данных входных условиях
    rejected = 3, // внешняя/физическая невозможность продолжать выполнение
};
```

2.3.2. Инварианты:

* Пока task находится в состояниях `INIT`, `WAIT` или `EXEC`, значение `code` обязано быть `unset`.
* При переходе task в состояние `DONE` её `code` обязан быть установлен в одно из значений перечисления и в дальнейшем не изменяться.
* Если `code == unset` в состоянии `DONE`, завершение task считается успешным.
* `panic` используется только для сигнализации о дефекте реализации (нарушение инвариантов, внутренняя ошибка ядра).
* `invalid` отражает невозможность продолжения выполнения по **логическим причинам** (предусловия, формат данных, протокольные условия, отсутствие следующего элемента и т.п.).
* `rejected` отражает невозможность продолжения выполнения по **внешним или физическим причинам** (ресурсы, таймауты, внешняя отмена).

---

## 2.4. Ресурсы (`Resources`)

2.4.1. Для каждой task ядро ведёт **монотонные ресурсные счётчики** фиксированного вида:

```text
struct Resources {
    wall:  u64; // суммарное "настенное" время существования задачи (нс)
    exec:  u64; // суммарное активное время исполнения в состоянии EXEC (нс)
    fuel:  u64; // абстрактный вычислительный бюджет
    shed:  u64; // количество планировочных включений задачи (входов в EXEC)

    errs:  u64; // количество ABI-вызовов, завершившихся с code != unset
    peak:  u64; // максимальный объём памяти в куче, занятый задачей, в байтах
    sent:  u64; // байты, логически отправленные в EMIT через emit(...)
    recv:  u64; // байты, логически прочитанные из SCAN через read(...)

    noop:  u64; // количество вызовов ABI noop() из данной задачи
    init:  u64; // количество вызовов ABI init(...) из данной задачи
    emit:  u64; // количество вызовов ABI emit(...) из данной задачи
    done:  u64; // количество вызовов ABI done(...) из данной задачи

    slot:  u64; // количество вызовов ABI slot() из данной задачи
    scan:  u64; // количество вызовов ABI scan(...) из данной задачи
    next:  u64; // количество вызовов ABI next(...) из данной задачи
    read:  u64; // количество вызовов ABI read(...) из данной задачи
}
```

2.4.2. Порядок и состав полей `Resources` **фиксированы** и не могут изменяться без новой мажорной версии спецификации.

2.4.3. Начальные значения:

* при появлении новой task в состоянии `INIT` все поля `resources` обязаны быть равны `0`;
* значения `resources` в состоянии `DONE` считаются итоговым потреблением и должны оставаться неизменными.

2.4.4. Монотонность:

* для любой task и любого поля `r` из `Resources` выполняется:

  ```text
  r(t) ≥ 0
  ```

* никакая корректная операция ядра не может уменьшать ни одно из полей `resources`;

* изменения ресурсных счётчиков допускаются только в виде **неотрицательных приращений**.

2.4.5. Семантика `wall` и `exec`:

* `wall` — оценка **общего** времени существования задачи от момента её создания до текущего момента, в наносекундах;
* `exec` — суммарное время активного исполнения задачи в состоянии `EXEC` (CPU-time / run-time);

Реализация обязана:

* не занижать преднамеренно общий прошедший интервал для `wall`;
* изменять `exec` только тогда, когда задача фактически находится в `EXEC`.

2.4.6. Семантика `fuel`:

* `fuel` — абстрактная мера “сложности” или “стоимости” исполнения;
* способ расчёта (по количеству инструкций, по числу ABI-вызовов, по профилированной стоимости операций и т.п.) определяется реализацией;
* при любой ненулевой работе задачи между двумя моментами наблюдения в состоянии `EXEC` приращение `fuel` должно быть строго положительным (с учётом дискретности и погрешностей измерений).

2.4.7. Семантика `shed`:

* `shed` — счётчик планировочных включений задачи;
* при каждом переходе задачи из `INIT` или `WAIT` в `EXEC` реализация должна увеличить `shed` как минимум на `1`.

2.4.8. Семантика `peak`:

* `peak` — максимальный объём памяти в куче, который когда-либо занимала задача за весь жизненный цикл, в байтах;
* реализация обязана гарантировать:

  * `peak` не меньше фактического максимума, измеренного по выбранной стратегии;
  * `peak` не уменьшается со временем.

2.4.9. Семантика `errs`:

* `errs` — количество ABI-вызовов, выполненных **из данной задачи**, которые вернулись с `code != unset` (включая `invalid`, `rejected`, `panic`);
* при каждом завершении ABI-вызова с `code != unset` реализация должна увеличить `errs` на `1`.

2.4.10. Семантика счётчиков вызовов (`spawn`, `init`, `emit`, `done`, `slot`, `scan`, `next`, `read`):

* каждый из этих счётчиков отражает **количество попыток вызова** соответствующей ABI-функции, сделанных из данной задачи (для `spawn` учитываются только успешные создания новых задач);
* счётчики увеличиваются на входе в соответствующий ABI-вызов (для `init`/`emit`/`done`/`slot`/`scan`/`next`/`read`) либо после подтверждения успешного создания (для `spawn`).

2.4.11. Семантика `sent` и `recv`:

* `sent` — суммарный логический объём событий/записей, отправленных задачей через `emit(...)`:

  * при каждом успешном (`code == unset`) вызове `emit(task_id, event_blob)` реализация должна увеличить `sent` на величину, не меньшую логического размера `event_blob` в байтах;

* `recv` — суммарный логический объём данных, прочитанных задачей через `read(...)`:

  * при каждом успешном (`code == unset`) вызове `read(slot, out_item_blob)` реализация должна увеличить `recv` на величину, не меньшую логического размера данных, записанных в `out_item_blob`.

2.4.12. Использование ресурсных счётчиков (лимиты, политики, биллинг, агрегация по `(grant_id, task_id)` и др.) **не входит** в область данной спецификации и задаётся надстройками. ZRK лишь гарантирует наличие, монотонность и минимальную семантику счётчиков.

2.4.13. Агрегация по `grant_id` (рекомендуемая практика):

* Реализация **может** трактовать ненулевой `grant_id` как указание на задачу-грант, на которую также агрегируются ресурсные приращения.
* В таком случае надстройки (например, GrantForge/ZBAC) могут:

  * суммировать `Resources` дочерних задач в `Resources` задачи-гранта;
  * использовать эти агрегаты для принятия решений о лимитах, throttling и запретах.

Конкретные правила агрегации по `grant_id` не нормируются ZRK.

---

## 2.5. Локальные слоты (`SlotId`)

2.5.1. **SlotId** — локальный идентификатор динамической ячейки данных внутри одной задачи:

```c
typedef uint16_t SlotId; // локальный слот внутри одной задачи
```

2.5.2. Каждый слот — это абстрактная **динамически типизированная локальная переменная**, чьё содержимое хранится в памяти текущей задачи. Содержимое слота может:

* интерпретироваться как бинарный blob;
* представлять структуру, описывающую задачу (Task-descriptor);
* содержать состояние сканера;
* иметь любой другой формат, определённый надстройками.

2.5.3. Для каждой пары `(current_task_id, SlotId)` реализуется отдельная локальная ячейка. Слоты разных задач независимы.

2.5.4. Логические операции над слотами:

* `is_slot_allocated(current_task, slot)` → {true, false};
* `kind_of_slot(current_task, slot)` → (тип содержимого слота), определено надстройками;
* `scanner_of_slot(current_task, slot)` → внутреннее состояние сканера, если слот используется как сканер.

ZRK не регламентирует внутренние структуры данных и типизацию содержимого слота, кроме минимально необходимого для работы SCAN-интерфейса.

2.5.5. Инварианты по слотам:

* при создании task все потенциальные `SlotId` считаются **неаллоцированными**;
* успешный вызов `slot()` возвращает новый `SlotId`, который считается аллоцированным для текущей задачи;
* надстройки могут накладывать дополнительные правила (например, “слот свободен/занят сканером/занят другим типом данных”).

2.5.6. Слоты не переживают завершения задачи: после перехода task в состояние `DONE` все её `SlotId` считаются недействительными.

---

## 2.6. Контекст вызова ABI

2.6.1. Каждый ABI-вызов выполняется **от имени некоторой текущей задачи**:

* `current_task_id : TaskId` — идентификатор задачи, в контексте которой выполняется вызов;
* текущий `state` обязан быть `EXEC` (вызовы из `INIT`, `WAIT`, `DONE` считаются нарушением спецификации).

2.6.2. В сигнатурах функций:

* `init/emit/done` принимают явный глобальный `TaskId`, к которому применяется действие;
* `slot/scan/next/read` работают с локальными `SlotId` текущей задачи, при этом `scan` дополнительно принимает `TaskId` цели сканирования.

2.6.3. Обращение к ABI из задачи в состоянии `DONE` запрещено и должно приводить к немедленному отказу (`panic` при нарушении инварианта реализации).

2.6.4. ZRK не определяет API для прямого изменения состояния чужих задач (создание/удаление, изменение `state`, `code`, `resources`), кроме операций `init` (создание новой задачи) и `done` (завершение задачи). Любые дополнительные cross-task операции реализуются над ZRK.

---

# 3. Жизненный цикл задачи

3.1. **Создание и настройка** задачи выполняется единым ABI-вызовом `init(...)` (§4.2.1).

3.2. При успешном `init`:

* создаётся новая задача с:

  * `task_id = new_id`;
  * `parent_id`:

    * либо равным `current_task_id` инициатора (`child-task`),
    * либо специальным “нулём” (при системном создании);
  * `algo_id` установленным из параметра `algo_id`;
  * `grant_id` установленным из параметра `grant_id`;
  * `state = INIT`;
  * `code = unset`;
  * `resources` обнулёнными;
* новый `task_id` возвращается в `out_task_id`.

3.3. **Работа** задачи:

* задача чередует состояния `WAIT` и `EXEC`, выполняя прикладной код и ABI-вызовы;
* переходы `WAIT ↔ EXEC` инициируются планировщиком, алгоритмами и внешними событиями.

3.4. **Завершение** задачи выполняется через `done(task_id, final_code)` (§4.2.3), либо при фатальном сбое реализации (`panic`).

3.5. Требования:

* любая наблюдаемая task появляется в системе в состоянии `INIT` с `code == unset` и `resources == 0`;
* каждая task в конечном итоге должна перейти в состояние `DONE`;
* никакая ABI-функция ZRK, кроме `init` и `done`, не создаёт и не завершает задачи;
* переходы состояний обязаны подчиняться §2.2.2;
* значения `resources.exec` и `resources.fuel` могут изменяться только в состоянии `EXEC`.

---

# 4. Поверхность ABI

## 4.1. Общие соглашения

4.1.1. Все ABI-функции возвращают `code` из §2.3:

* `unset` — успешное выполнение;
* `panic`, `invalid`, `rejected` — различные классы отказов.

4.1.2. Все параметры вида `*_blob` — **опаковые бинарные блоки**. Их формат и семантика определяются над уровнем ZRK (например, в ZDK/профилях). На уровне реализации они могут храниться в локальных слотах или в иной памяти задачи.

4.1.3. Для фиксированных:

* `TaskId`;
* `SlotId`;
* `AlgoId`;
* входных `*_blob`;
* версии алгоритма,

поведение операций `init/emit/done/scan/next/read` должно быть **детерминированным**.

4.1.4. Нормативные требования к росту ресурсных счётчиков при вызовах ABI приведены в §2.4.

---

## 4.2. EMIT-плоскость: глобальные задачи и события

### 4.2.1. Создание и инициализация задачи: `init(...)`

```c
init(
    out_task_id, // выходной параметр: новый TaskId
    algo_id,     // AlgoId: идентификатор алгоритма
    grant_id,    // TaskId: идентификатор задачи-гранта или "нулевое" значение
    cfg_blob     // опаковый бинарный блок конфигурации алгоритма
) -> code;
```

4.2.1.1. При каждом вызове `init` реализация:

* увеличивает `resources.init` текущей задачи как минимум на `1`.

4.2.1.2. При успешном выполнении:

* создаётся новая задача:

  * `task_id = new_id`;
  * `parent_id`:

    * либо `current_task_id` инициатора,
    * либо специальное “нулевое” значение — при системном создании;
  * `algo_id = algo_id` (из параметра);
  * `grant_id = grant_id` (из параметра);
  * `state = INIT`;
  * `code = unset`;
  * `resources` обнуляются;

* новый `task_id` записывается в `out_task_id`;

* у текущей задачи увеличивается `resources.spawn` как минимум на `1`;

* возвращается `code == unset`.

4.2.1.3. При ошибке:

* новая задача не считается созданной;
* `out_task_id` считается неопределённым и не должен использоваться;
* возвращается неуспешный код (`invalid`, `rejected` или `panic`).

---

### 4.2.2. Запись события: `emit(...)`

```c
emit(
    task_id,     // TaskId: глобальный идентификатор алгоритма/задачи
    event_blob   // бинарное представление события/записи
) -> code;
```

4.2.2.1. `emit` — базовая операция добавления события/записи в глобальное состояние алгоритма задачи `task_id`.

4.2.2.2. Предусловия:

* задача `task_id` существует и не находится в состоянии `DONE`;
* к задаче привязан алгоритм `algo_id`, поддерживающий приём событий.

4.2.2.3. При каждом входе в `emit` реализация:

* увеличивает `resources.emit` текущей задачи как минимум на `1`.

4.2.2.4. При успешном выполнении:

* внутреннее состояние алгоритма `task_id` обновляется с учётом `event_blob`;
* у текущей задачи увеличивается `resources.sent` согласно §2.4.11;
* `resources.fuel` и `resources.exec` могут увеличиваться согласно модели реализации;
* возвращается `code == unset`.

4.2.2.5. При невозможности применить событие (несовместимый формат, нарушение условий, отсутствующий алгоритм, `DONE` и т.п.):

* состояние алгоритма `task_id` не изменяется;
* возвращается `code == invalid` (либо `rejected` при внешних причинах).

---

### 4.2.3. Завершение задачи: `done(...)`

```c
done(
    task_id,    // TaskId: идентификатор завершаемой задачи
    final_code  // итоговый код завершения: unset / panic / invalid / rejected
) -> code;
```

4.2.3.1. При каждом входе в `done` реализация:

* увеличивает `resources.done` текущей задачи как минимум на `1`.

4.2.3.2. Предусловия успешного завершения:

* задача `task_id` существует;
* задача `task_id` находится не в состоянии `DONE`.

4.2.3.3. При успешном выполнении:

* задача `task_id` переводится в состояние `DONE`;
* её `code` устанавливается в `final_code`;
* любые последующие операции `init` (повторная инициализация), `emit`, повторный `done` и SCAN по этой задаче выполняются в соответствии с политикой надстроек, но не могут изменить `state` и `code` данной задачи;
* возвращается `code == unset` как код успешного выполнения самого ABI-вызова.

4.2.3.4. Повторный вызов `done` для одного и того же `task_id`:

* **не** должен приводить к `panic`;
* обязан возвращать `code == invalid`;
* не изменяет состояние уже завершённой задачи.

---

## 4.3. SCAN/LOCAL-плоскость: локальные слоты и сканирование

### 4.3.1. Выделение локального слота: `slot()`

```c
slot(
    out_slot_id // выходной параметр: новый SlotId для текущей задачи
) -> code;
```

4.3.1.1. При успешном выполнении:

* для текущей задачи аллоцируется новый слот, не используемый ранее или корректно освобождённый;
* идентификатор слота записывается в `out_slot_id`;
* у текущей задачи увеличивается `resources.slot` как минимум на `1`;
* возвращается `code == unset`.

4.3.1.2. Содержимое нового слота считается неопределённым до первого присваивания надстройками. ZRK не регламентирует операции записи в слот, кроме тех, что косвенно меняют его содержимое (например, создание сканера через `scan`).

---

### 4.3.2. Инициализация сканера: `scan(...)`

```c
scan(
    slot,      // SlotId: локальный слот в текущей задаче
    task_id,   // TaskId: глобальная задача/алгоритм, по которому сканируем
    cfg_blob   // опаковая конфигурация сканера/представления
) -> code;
```

4.3.2.1. Предусловия:

* слот `slot` аллоцирован для текущей задачи;
* в слоте `slot` либо нет активного сканера, либо надстройки допускают переинициализацию;
* задача `task_id` существует (не обязательно совпадает с текущей задачей).

4.3.2.2. При успешном выполнении:

* в слоте `slot` создаётся сканер, читающий логическое состояние алгоритма задачи `task_id` согласно `cfg_blob`;
* содержимое слота становится структурой состояния сканера (тип и формат определяются надстройками);
* у текущей задачи увеличивается `resources.scan` как минимум на `1`;
* возвращается `code == unset`.

4.3.2.3. При ошибке:

* сканер не считается созданным;
* слот остаётся в исходном состоянии;
* возвращается неуспешный код.

---

### 4.3.3. Продвижение курсора: `next(...)`

```c
next(
    slot,        // SlotId
    params_blob  // параметры шага сканирования (фильтры, лимиты и т.п.)
) -> code;
```

4.3.3.1. `next` продвигает внутренний курсор сканера в слоте `slot`.

4.3.3.2. Предусловия:

* в слоте `slot` существует активный сканер.

4.3.3.3. При каждом входе в `next` реализация:

* увеличивает `resources.next` текущей задачи как минимум на `1`.

4.3.3.4. При успешном выполнении:

* сканер обновляет своё внутреннее состояние (перемещается к следующему элементу/диапазону);
* возвращается `code == unset`.

4.3.3.5. При отсутствии дальнейших элементов **на момент вызова** (конец потока, исчерпание диапазона, отсутствие данных):

* операция обязана вернуть `code == invalid` как логическую невозможность предоставить следующий элемент при текущих условиях;
* ZRK не вводит специального `EOF`-состояния.

---

### 4.3.4. Чтение текущего элемента: `read(...)`

```c
read(
    slot,          // SlotId
    out_item_blob  // бинарное представление текущего элемента
) -> code;
```

4.3.4.1. `read` возвращает текущий элемент, подготовленный предшествующими вызовами `next` и внутренней логикой сканера.

4.3.4.2. При наличии элемента:

* сериализованный элемент записывается в `out_item_blob`;
* у текущей задачи увеличиваются:

  * `resources.read` как минимум на `1`;
  * `resources.recv` согласно §2.4.11;
* возвращается `code == unset`.

4.3.4.3. При отсутствии элемента по любой причине (ещё не был вызван `next`, достигнут конец потока, данные ещё не доступны):

* `read` обязан вернуть `code == invalid`;
* на уровне ZRK не различаются “конец данных” и “данные ещё не готовы” — обе ситуации трактуются как логическая невозможность получить элемент в текущем контексте.

---

## 4.4. Нумерация операций (`OpKind`)

4.4.1. Для целей Run Policy / CBAC (GrantForge/ZBAC) вводится перечисление `OpKind`, отображающее ABI-операции в целочисленные коды:

```c
enum OpKind {
    Noop = 0, // noop()
    Init = 1, // init(...)
    Emit = 2, // emit(...)
    Done = 3, // done(...)

    Slot = 4, // slot()
    Scan = 5, // scan(...)
    Next = 6, // next(...)
    Read = 7, // read(...)
};
```

4.4.2. Нумерация является **фиксированной** частью ZRK и используется надстройками:

* в политике прав (`AlgoId * OpKind`);
* в GrantForge/ZBAC для принятия решений по ABI-вызовам.

---

# 5. Асинхронность и изоляция

5.1. ZRK должен обеспечивать возможность одновременного существования и выполнения множества задач без неконтролируемого взаимного влияния.

5.2. Ошибка `panic` в одной задаче не должна автоматически нарушать корректность других задач. Реализация может переводить зависимые задачи в `DONE` с `rejected` или другим кодом, согласованным с политикой узла, но обязана сохранять инварианты состояний и кодов.

5.3. Любая долговременная операция ожидания внешних условий (IO, таймеры, блокировки) должна оформляться переводом задачи в `WAIT` и последующим возвращением в `EXEC`. Конкретные механизмы ожидания и пробуждения (события, планировщик, host-протоколы) определяются над ZRK.

5.4. Операции EMIT (`init/emit/done`) не должны выполнять блокирующие ожидания, кроме как через переходы `WAIT/EXEC`, согласованные с планировщиком.

5.5. Операции SCAN (`slot/scan/next/read`) не должны нарушать изоляцию глобальных состояний задач: чтение через SCAN не может прямым образом модифицировать состояние задачи-источника.

5.6. Любые прямые обращения к физическим ресурсам (железо, драйверы, сеть, диски) должны происходить за пределами ZRK, через надстроечные алгоритмы (`AlgoId`) и протоколы, использующие EMIT/SCAN.

---

# 6. Глобальные инварианты модели

## 6.1. Состояния и коды

* Task всегда находится ровно в одном состоянии из {`INIT`, `WAIT`, `EXEC`, `DONE`}.
* Допустимы только переходы состояний, перечисленные в §2.2.2.
* В состояниях `INIT`/`WAIT`/`EXEC` код завершения всегда `unset`.
* В состоянии `DONE` код фиксируется и не изменяется.

---

## 6.2. Терминальность DONE

* Ни одна ABI-функция не может перевести задачу из `DONE` в иное состояние.
* Ни одна ABI-функция не может изменить `code` задачи после перехода в `DONE`.
* Повторный `done(task_id, ...)` для уже завершённой задачи всегда возвращает `invalid` и не изменяет состояние.

---

## 6.3. Ресурсы

* При появлении task в состоянии `INIT` все поля `resources` равны `0`.
* Ни одна корректная операция ядра не уменьшает ни одно из полей `resources`.
* `resources.exec` и `resources.fuel` изменяются только в состоянии `EXEC`.
* `resources.shed` увеличивается при каждом входе задачи в `EXEC`.
* `resources.peak` не уменьшается.
* `resources.errs` увеличивается при каждом завершении ABI-вызова с `code != unset`.
* Счётчики вызовов (`spawn/init/emit/done/slot/scan/next/read`) увеличиваются при соответствующих ABI-вызовах.
* `resources.sent` и `resources.recv` изменяются только через `emit` и `read` соответственно.

---

## 6.4. Слоты и сканеры

* Для каждой пары `(current_task_id, SlotId)` существует не более одного активного сканера.
* `slot()` — единственный ABI, аллоцирующий новые `SlotId` для текущей задачи.
* `scan/next/read` по неаллоцированному слоту или без активного сканера должны возвращать неуспешный код.
* Слоты не переживают завершения задачи: после `DONE` текущей задачи все её слоты считаются недействительными.

---

## 6.5. Детерминизм

* Для фиксированных входных данных и конфигурации алгоритма поведение операций:

  * `init/emit/done`;
  * `scan/next/read`;

  обязано быть детерминированным.

---

## 6.6. Отсутствие EOF и единая семантика отсутствия данных

* ZRK не вводит отдельного состояния/кода EOF.
* Любая попытка прочитать элемент при отсутствии доступного элемента (`read`) должна возвращать `code == invalid`.
* Попытка продвинуть курсор при отсутствии следующего элемента (`next`) должна возвращать `code == invalid`.
* Интерпретация этих ситуаций (конец потока, нет данных, ещё не готовы) задаётся надстройками.

---

## 6.7. Расширяемость

* Добавление новых алгоритмов (`AlgoId`), форматов `*_blob` и профилей допускается без изменения данной спецификации при соблюдении всех инвариантов.
* Добавление новых ABI-функций требует новой версии спецификации и расширения `OpKind`.

---

## 6.8. Нейтральность к реализациям

* ZRK не навязывает:

  * структуру WAL и индексов;
  * стратегию шардирования и репликации;
  * формат снимков состояния и внутреннее представление `*_blob` и содержимого слотов.

* Любая реализация, соблюдающая:

  * модель task и её состояний;
  * ресурсные инварианты;
  * дисциплину слотов;
  * детерминизм операций `init/emit/done/scan/next/read`,

  считается совместимой с **ZeroBus Task Kernel v1.3.0**.
