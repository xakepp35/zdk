# ZeroBus Scan Engine (ZSE) v1

```spec
File:    spec/zse.v1.ru.md
Owner:   xakepp35
Version: v1.2.1
Updated: 2025-11-23
License: Apache 2.0
Depends: spec/zrk.v1.ru.md, spec/zdk.v1.ru.md
```

## 1. Назначение и область действия

1.1. Настоящая спецификация определяет модель **ZeroBus Scan Engine (ZSE)** — универсального механизма чтения глобальных состояний задач через ABI-плоскость SCAN (`slot/scan/next/read`) ядра ZRK.

1.2. ZSE задаёт:

* физику версий состояния задачи и их связь с WAL;
* модель **Scan Provider** как части AlgoId-драйвера источника;
* модель жизненного цикла сканера (**Cursor**) и разделение на handle/executor;
* режимы сканирования (snapshot / live);
* модель **ScanProgram IR** как единственного pushdown-контракта чтения;
* протокол шагового управления курсором (**ScanStep**) и батч-семантику;
* требования к локальности исполнения, изоляции, детерминизму, ресурсам и освобождению версий;
* контракт **ScanCapabilities** для AlgoId-семейств (ZDK).

1.3. ZSE **не нормирует**:

* конкретные бинарные форматы IR и шаговых параметров;
* внутренние структуры данных AlgoId-драйверов;
* стратегии WAL-хранилищ, индексирования, репликации и снапшотов;
* сетевые протоколы маршрутизации Cursor к Source.

Все такие элементы считаются опаковыми и задаются профилями ZDK и реализациями узла.

---

## 2. Термины и сущности

2.1. **Источник (Source task)** — глобальная задача `task_id`, чьё состояние сканируется.

2.2. **Читатель (Reader task)** — текущая задача, выполняющая `scan/next/read`.

2.3. **Версия состояния (Version)** — монотонное целое `V ∈ u64`, однозначно соответствующее позиции применения WAL:

* `V = 0` — начальная версия (пустое состояние);
* каждое успешно применённое событие `emit` порождает следующую версию `V+1`.

2.4. **Корень версии (Root(V))** — опаковый immutable-handle на логическое состояние источника на версии `V`.

2.5. **Scan View / ViewCall** — вид/точка входа чтения, объявленная Source AlgoId в ScanCapabilities. На уровне ScanProgram это выражено как IR-вызов к источнику, например `range(...)`, `point(...)`, `iter(...)`, `knn(...)`, `agg(...)`.

2.6. **ScanProgram IR** — чистая потоковая IR-программа чтения, передаваемая в `scan` и фиксируемая в Cursor. ScanProgram состоит из:

* **ViewCall** (IR-вызов источника, выбирающий поток кандидатов);
* цепочки **Expr** — чистых jq/zq-подобных выражений без эффектов, применяемых к потоку.

2.7. **Expr** — потоковое выражение типа:

```text
Expr : InRow -> Option<OutRow>
```

где:

* `None` означает отбрасывание элемента (filter);
* `Some(v)` означает прохождение элемента и возможное преобразование (map/projection).

На уровне ZSE отдельные “filter” и “map” не различаются.

2.8. **Scan Provider** — часть AlgoId-драйвера Source task, реализующая создание и выполнение Cursor-сканов по Root(V).

2.9. **Cursor (инстанс сканера)** — опаковый объект обхода, созданный `scan` для конкретного `(task_id, pinned_version, scan_program, mode)`.

2.10. **Pinned version** — версия `V`, закреплённая за Cursor и гарантирующая неизменность наблюдаемого состояния.

2.11. **Cursor-executor** — выполняющаяся у источника часть Cursor (рядом с данными), исполняющая ViewCall и Expr.

2.12. **Cursor-handle** — локальный дескриптор Cursor в Reader task, размещённый в slot и маршрутизирующий `next/read` к executor.

2.13. **ScanStep** — шаговое управляющее сообщение, передаваемое в `next` для получения следующего батча результатов.

2.14. **Сканер-алгоритм (Scanner algorithm)** — обычная task с AlgoId, которая читает другие задачи через ZSE и строит собственное состояние. Это **не** Cursor и не нормируется ZSE отдельно.

---

## 3. Физика версий и связь с WAL

3.1. Для каждой Source task существует WAL, определяющий единственный детерминированный порядок событий.

3.2. Reducer Source task является **единственным писателем** глобального состояния. Операции SCAN не могут модифицировать состояние Source task.

3.3. Применение событий WAL порождает последовательность версий:

```text
Root(0) --E1--> Root(1) --E2--> Root(2) -- ...
```

3.4. Для фиксированного WAL-префикса до версии `V` Root(V) обязан быть **единственным** и **детерминированным**.

3.5. Публикация новой текущей версии Root(V) обязана быть атомарной операцией (swap корня), исключающей необходимость reader-locks.

---

## 4. Scan Provider (контракт источника)

4.1. Каждый AlgoId-драйвер Source task, объявляющий хотя бы один Scan View, обязан предоставлять Scan Provider.

4.2. Минимальный интерфейс Scan Provider:

```text
ScanProvider {
  Open(rootV, scan_program_ir) -> cursor_id | code
  Next(cursor_id, step_blob)   -> code
  Read(cursor_id, out_blob)    -> code
  Close(cursor_id)            -> void
}
```

4.3. `cursor_id` — опаковый идентификатор Cursor-executor у источника.

4.4. Scan Provider **обязан**:

* валидировать ScanProgram IR и ScanStep на соответствие ScanCapabilities;
* исполнять ScanProgram локально у источника (data locality);
* обеспечивать батч-семантику результатов (§7.6);
* обеспечивать детерминизм для фиксированных входов (§11).

4.5. Scan Provider **может** распознавать частные паттерны ScanProgram IR и подменять их более быстрыми нативными обходами (внутренняя оптимизация). Это не влияет на наблюдаемую семантику ScanProgram.

---

## 5. Жизненный цикл Cursor

### 5.1. Создание (scan)

5.1.1. `scan(slot, task_id, cfg_blob)`:

* выбирает `pinned_version = V` согласно §6;
* трактует `cfg_blob` как **scan_program_ir**;
* вызывает `ScanProvider.Open(Root(V), scan_program_ir)` у источника;
* при успехе размещает Cursor-handle в slot Reader task.

5.1.2. Cursor-handle фиксирует:

* `source_task_id = task_id`;
* `pinned_version = V`;
* `mode ∈ {Snapshot, Live}` (задано ScanProgram IR);
* `cursor_id` (ид источникового executor);
* `route_hint` (опаковая информация маршрутизации/шарда).

5.1.3. ScanProgram IR является **неизменяемым** для данного Cursor: после успешного `scan` он не может расширяться или заменяться через `next/read`.

5.1.4. Cursor-executor существует у источника до `Close(cursor_id)` либо до завершения Reader task.

5.1.5. Одновременно могут существовать многие Cursor-инстансы для одной Source task, каждый со своим pinned_version.

### 5.2. Продвижение (next)

5.2.1. `next(slot, params_blob)`:

* извлекает Cursor-handle;
* трактует `params_blob` как **ScanStep**;
* маршрутизирует вызов в `ScanProvider.Next(cursor_id, step_blob)` у источника.

5.2.2. Next обязан подготовить следующий **батч** результатов ScanProgram.

5.2.3. Если на момент вызова ScanProgram не может предоставить следующий батч (конец snapshot или отсутствие данных в live), Next обязан вернуть `code == invalid`.

### 5.3. Чтение (read)

5.3.1. `read(slot, out_item_blob)`:

* извлекает Cursor-handle;
* маршрутизирует вызов в `ScanProvider.Read(cursor_id, out_item_blob)` у источника.

5.3.2. Read обязан вернуть текущий подготовленный батч результатов.

5.3.3. При отсутствии подготовленного батча Read обязан вернуть `code == invalid`.

### 5.4. Закрытие

5.4.1. Освобождение Cursor является обязанностью Reader task/надстроек.

5.4.2. При освобождении slot надстройки обязаны вызвать `ScanProvider.Close(cursor_id)`.

5.4.3. При переходе Reader task в DONE все её Cursor считаются закрытыми.

---

## 6. Режимы сканирования

### 6.1. Snapshot scan

6.1.1. Snapshot Cursor работает только с Root(pinned_version).

6.1.2. Snapshot Cursor не наблюдает события после pinned_version.

6.1.3. pinned_version в Snapshot режиме обязан быть текущей наблюдаемой версией Source task на момент scan.

### 6.2. Live scan (tailing)

6.2.1. Live Cursor допустим только если Source AlgoId объявил `live = true` в ScanCapabilities.

6.2.2. Live Cursor читает:

* сначала Root(V0);
* затем WAL-хвост `E(V0+1 .. )` строго в порядке WAL.

6.2.3. pinned_version в Live режиме обязан быть стартовой версией V0.

6.2.4. Отсутствие новых событий/элементов для Live Cursor трактуется как `invalid` на Next/Read (ZRK §6.6).

---

## 7. ScanProgram IR и ScanStep

7.1. **ScanProgram IR** является единственным pushdown-контрактом чтения.

7.2. ScanProgram IR включает:

* ViewCall, выбирающий поток кандидатов у источника;
* потоковые Expr, преобразующие поток кандидатов в поток результатов;
* флаг режима (`Snapshot`/`Live`);
* опциональные подсказки батчинга (не обязательные для исполнения, но допускаемые capabilities).

7.3. Expr ScanProgram:

* чистые (pure), без побочных эффектов;
* не содержат mutable-состояния;
* не выполняют IO/Host/Emit/Scan-операций;
* детерминированы на уровне `InRow -> Option<OutRow>`.

Нарушение этих требований считается дефектом реализации и должно приводить к `panic`.

7.4. IR-выражения валидируются Scan Provider’ом против схемы Source:

* доступ к полям осуществляется по фиксированной схеме ZeroBus;
* обращение к отсутствующему полю/типу должно приводить к `invalid` на этапе Open.

7.5. **ScanStep (params_blob)** задаёт только управление курсором и батчем и не содержит бизнес-логики фильтра/проекции. Минимально допускаются:

* `limit` — желаемый размер следующего батча;
* `seek_ir?` — опциональная маленькая IR-команда перепозиционирования **в пределах текущего ViewCall**, если это объявлено capabilities.

`seek_ir` не может:

* менять ViewCall;
* добавлять/заменять Expr;
* изменять режим Snapshot/Live.

7.6. Scan Provider обязан подготавливать результаты батчами. Семантика батча (rows/columnar/scalar/offset-len и т.п.) задаётся ViewCall и Expr и относится к бинарному формату `out_item_blob`.

7.7. Если ScanProgram или ScanStep выходят за пределы ScanCapabilities или политик профиля, операции `scan/next/read` обязаны вернуть `invalid` либо `rejected`.

---

## 8. ScanCapabilities (контракт ZDK)

8.1. Для каждого AlgoId-семейства ZDK обязан объявлять ScanCapabilities:

```text
ScanCapabilities = {
  views:   [ViewId...],     // разрешённые ViewCall
  outputs: [OutId...]?,     // допустимые формы/кодировки результата (опционально)

  ir: {
    allowed_ops:     [OpId...],     // подмножество jq/zq-операций
    builtins:        [ApiId...],    // algo-specific хелперы
    max_fuel_item:   u64,           // тех. лимит IR-стоимости на элемент/батч
    max_fuel_scan:   u64,           // тех. лимит IR-стоимости на ScanProgram
    max_batch_items: u32?,          // тех. лимит размера батча (опционально)
    max_batch_bytes: u64?,          // тех. лимит размера батча (опционально)
    jit:             bool,          // допускается ли JIT/кэширование
  },

  live: bool,               // поддержка live-scan
}
```

8.2. ViewId/OutId/OpId/ApiId опаковые и задаются профилями AlgoId.

8.3. Scan Provider обязан:

* принимать только ViewCall, IR-операции и output-формы из capabilities;
* отклонять выход за технические лимиты топлива/батча.

---

## 9. Изоляция и отсутствие гонок

9.1. Reducer Source task — единственный модификатор глобального состояния.

9.2. Cursor читает immutable Root(V) и не требует RWMutex на “живой” структуре данных.

9.3. Параллельные Cursor для одной Source task:

* не конфликтуют друг с другом;
* не конфликтуют с emit;
* наблюдают каждый свою pinned_version.

9.4. Конструкция SCAN исключает “concurrent map read and write” как класс ошибок при корректной реализации Scan Provider.

---

## 10. Управление версиями и освобождение памяти

10.1. Source task обязана поддерживать восстановление Root(V) для любых pinned_version активных Cursor.

10.2. Scan Engine ведёт watermark:

```text
min_pinned_version = min(Cursor.pinned_version over active cursors)
```

10.3. Версии `< min_pinned_version` могут быть слиты в checkpoint/освобождены/скомпакчены при сохранении детерминизма Root(V) для `V ≥ min_pinned_version`.

10.4. Стратегии чекпоинтов и компакции опаковы и определяются профилем AlgoId и реализацией WAL.

---

## 11. Детерминизм

11.1. Для фиксированных:

* WAL-префикса до версии V;
* AlgoId и его версии;
* ScanProgram IR;
* последовательности ScanStep;

последовательность результатов `(Next, Read)` обязана быть детерминированной.

11.2. Любой недетерминизм Scan Provider/AlgoId-драйвера является нарушением ZRK/ZSE и должен приводить к `panic` при выявлении.

---

## 12. Ресурсы SCAN

12.1. Учёт ресурсов выполняется **строго по ZRK**. В частности:

* счётчики `scan/next/read` увеличиваются при каждом входе в соответствующий ABI-вызов (успех или ошибка);
* `recv` увеличивается только на успешный `read` согласно ZRK §2.4.11;
* `errs` увеличивается при завершении ABI-вызова с `code != unset`.

12.2. Scan Provider и Scan Engine могут увеличивать `fuel/exec` Reader task согласно фактической работе ScanProgram.

12.3. Политики лимитов/троттлинга SCAN определяются надстройками (GrantForge/ZBAC) через ресурсы ZRK и не влияют на инварианты ZSE.

---

## 13. Коды ошибок

13.1. `invalid` — логические причины:

* ViewCall/OpId/ApiId/OutId не поддерживается ScanCapabilities;
* ScanProgram обращается к отсутствующим полям/типам схемы Source;
* конец данных в Snapshot;
* отсутствие данных “на сейчас” в Live;
* некорректный ScanStep или невозможность подготовить следующий батч.

13.2. `rejected` — внешние причины:

* превышение лимитов топлива/ресурсов;
* запрет политикой грантов;
* физическая недоступность источника/шарда.

13.3. `panic` — дефекты реализации Scan Provider/AlgoId/ZSE или нарушение инвариантов чистоты/детерминизма IR.

---

## 14. Совместимость

14.1. Реализация совместима с ZSE v1.2.1, если соблюдает:

* модель версий и pinned_version;
* Scan Provider и локальность исполнения;
* lifecycle Cursor с handle/executor;
* ScanProgram IR как единственный pushdown-контракт;
* ограничения ScanCapabilities;
* изоляцию от emit;
* детерминизм;
* watermark-освобождение версий;
* ресурсные инварианты ZRK.

14.2. Любое расширение ABI (`slot/scan/next/read`) или ScanCapabilities требует новой версии ZSE и расширения ZRK OpKind.
