# Спецификация ZeroBus Development Kit (ZDK)

```spec
File:   spec/zdk.v1.ru.md
Owner:  xakepp35
Version: v1.0.1
Updated: 2025-11-20
License: Apache 2.0
Depends: spec/zrk.v1.ru.md
```

## 1. Область действия, цели и назначение

1.1. Настоящая спецификация определяет **ZeroBus Development Kit (ZDK)** — открытый каталог классов, семейств и примитивов ZeroBus, а также единый формат работы с ними на стороне хоста.

1.2. Спецификация ZDK **опирается на модель ядра**, определённую в документе **ZeroBus Run Kernel (ZRK)**:

* понятия `Run`, `RunId`, `space`, `state`, `code`;
* четыре пространства исполнения: `HOST`, `EMIT`, `SCAN`, `TASK`;
* минимальный набор ABI-функций ядра.

Настоящий документ **не повторяет** эти определения и использует термины ZRK без повторных пояснений.

1.3. ZDK устанавливает:

* структуру 32-битного идентификатора примитива (**KindId**) и правила его использования;
* реестр классов (`class`), семейств (`family`) и вариантов (`variant`) примитивов;
* абстрактную модель взаимодействия хост-процесса с ядром ZRK через плоскость `HOST`;
* профили ZDK (Core/UI/Web) и состав примитивов, входящих в каждый профиль.

1.4. ZDK **не описывает**:

* внутренние алгоритмы реализации ZRK;
* внутренний формат исполнений (Rust-бинарь, WASM-модуль) и криптографические детали упаковки;
* конкретный бинарный протокол обмена между хостом и ядром (линейное представление сообщений, выравнивание, endianess).

Все такие детали являются внутренними для реализации и могут изменяться при сохранении описанных ниже контрактов.

---

## 2. Лицензирование, открытость и состав поставки

2.1. **Открытая часть (репозиторий ZDK)**

* Все файлы в репозитории `zdk` (спеки, заголовки, описания форматов, справочники и схемы) лицензируются под **Apache 2.0**.
* Открытая часть включает:

  * настоящую спецификацию ZDK;
  * реестр KindId (классы, семейства, варианты);
  * текстовые описания примитивов и их семантики;
  * открытые SDK-обвязки для языков (Rust/Go/TypeScript) на стороне хоста, в пределах описанных контрактов.

2.2. **Закрытая часть (исполняемые модули)**

Существует закрытая проприетарная реализация, поставляемая в виде шифрованных исполнимых модулей/блобов. В её состав входят:

* реализация ядра **ZeroBus Run Kernel (ZRK)**;
* системные HOST-примитивы и драйверы (I/O, сетевые, криптографические и др.);
* примитивы WAL (журнал узла) и связанные с ними алгоритмы;
* примитивы UI (рендеринг, layout, виджеты, текст, темы), включая браузерный профиль.

2.3. **Версии и лицензии узла ZeroBus**

* Закрытая реализация присутствует в сборке узла `zb`.
* В **community-версии**:

  * часть примитивов недоступна, либо реализована в базовом (неоптимизированном) варианте;
  * UI-примитивы и клиентская часть могут отсутствовать или быть ограничены.
* Для использования оптимизированных алгоритмов (ускоренные индексы, ANN, скетчи, WAL) и клиентских UI-примитивов (браузерный/нативный рендер) требуется **лицензионный грант** (премиум-функциональность).

2.4. **Роль ZDK**

* ZDK определяет **стабильный внешний контракт**, по которому:

  * закрытые модули должны себя вести;
  * открытые и сторонние реализации могут быть подключены.
* ЗDK **не различает** community и premium с точки зрения API: различается только набор доступных KindId и качество/сложность внутренних алгоритмов.

---

## 3. Архитектурная модель ZDK относительно ZRK

3.1. **Форма исполнения ядра ZRK**

* Ядро ZRK существует в двух основных исполнениях:

  * **нативный Rust-бинарь**;
  * **WASM-модуль**, пригодный для запуска в браузере или встроенной среде.
* Оба исполнения рассматриваются как **чёрный ящик**, реализующий ZRK-спеку и поддерживающий ZDK-контракты.

3.2. **Размещение ядра относительно хоста**

* ZRK **всегда исполняется рядом** с хост-приложением:

  * в отдельном процессе (узел ZeroBus);
  * либо в отдельном треде внутри того же процесса (встраиваемый режим);
  * либо в отдельном WASM-контейнере (браузер/встраиваемая платформа).
* Во всех вариантах размещения выполнение ZRK считается **изолированным**, а хост и ядро общаются через формализованный шлюз.

3.3. **Единственный канал взаимодействия: HOST-шлюз**

3.3.1. Взаимодействие хост-процесса с ядром ZRK осуществляется **только** через плоскость `HOST`.

Любые операции уровня `TASK`, `EMIT`, `SCAN` доступны хосту исключительно как команды, инкапсулированные в запросы к HOST-шлюзу.

3.3.2. На уровне ZDK это выражается в виде абстракции:

> **Host Gateway** — минимальная функция/точка входа ядра, принимающая бинарный запрос и возвращающая бинарный ответ, интерпретацию которых задаёт ZDK.

Конкретная сигнатура и детализация wire-формата зависят от языка/платформы, но логически:

* каждый запрос описывает:

  * идентификатор целевого `RunId`;
  * тип операции (класс/семейство/вариант, действие);
  * бинарные параметры;
* каждый ответ описывает:

  * результат действия;
  * возможные выходные данные;
  * изменения состояния (через стандартные механизмы ZRK).

3.3.3. Даже при линковке ZRK как Rust-библиотеки к тому же бинарнику, где живёт бизнес-код, **прямые вызовы внутренних функций ядра запрещены**.

Хост-код обязан обращаться к ядру только через:

* Host Gateway (встроенный FFI/ABI-шлюз);
* и, соответственно, только через семантику классов/семейств/примитивов, описанную в ZDK.

3.4. **Роль ZDK в этой модели**

ZDK фиксирует:

* какие классы и семейства примитивов существуют;
* какие KindId за ними закреплены;
* какой **смысл** у операций над этими примитивами, инициируемых через Host Gateway;
* какие наборы примитивов входят в различные профили (Core/UI/Web).

ZDK **не определяет**, как именно ядро реализует эти операции внутри, но требует соблюдения описанных инвариантов и семантики.

---

## 4. KindId: идентификатор примитива

4.1. **Структура KindId**

Каждый примитив ZeroBus, доступный через ZDK, имеет 32-битный идентификатор:

```text
KindId = (class << 24) | (family << 16) | variant
```

где:

* `class`  (8 бит, старшие)   — крупный класс сущностей;
* `family` (8 бит, средние)   — семейство внутри класса;
* `variant` (16 бит, младшие) — конкретный вариант/алгоритм/драйвер.

4.2. **Инварианты KindId**

4.2.1. Для всех зарегистрированных примитивов в рамках ZDK v1:

* комбинация `(class, family, variant)` уникальна;
* значения `class` и `family` фиксированы данной спецификацией;
* значения `variant` могут иметь зарезервированные диапазоны для:

  * базовых реализаций (0x0001–0x0FFF);
  * оптимизированных/премиум (0x1000–0x1FFF);
  * пользовательских расширений (0x8000–0xFFFF).

4.2.2. Реестр KindId ведётся как часть артефактов ZDK и расширяется совместимо:

* добавление новых KindId допускается;
* изменение семантики существующего KindId требует повышения major-версии ZDK.

4.2.3. Ядро ZRK рассматривает KindId как опаковое значение; его внутреннее разбор/маршрутизация зависят от реализации, но должны сохранять поведение, описанное для данного KindId в ZDK.

---

## 5. Классы и семейства ZDK v1

Настоящий раздел фиксирует **полный каталог классов и семейств примитивов** ZDK v1, а также ключевые варианты алгоритмов внутри них.

Каждый примитив имеет 32-битный `KindId`:

```text
KindId = (class << 24) | (family << 16) | variant
```

где:

* `class`  — 8-битный код класса;
* `family` — 8-битный код семейства внутри класса;
* `variant` — 16-битный код конкретного варианта/алгоритма.

### 5.1. Класс 0x01 — HOST_DEV

5.1.1. **Назначение**

Класс `HOST_DEV` описывает **драйверы среды** — всё, чем ядро ZRK общается с внешним миром через плоскость `HOST`:

* транспорт (потоки/соединения),
* блочные устройства,
* объектные/KV-хранилища,
* источники UI-событий и поверхности рендера,
* web-специфичные хранилища.

Хост-разработчик не управляет ими напрямую: он конфигурирует и вызывает их **через Host Gateway**, а реализация внутри ZRK остаётся чёрным ящиком.

---

#### 5.1.2. Семейство 0x01 — STREAM (потоковые драйверы)

**Семейство**: `class = 0x01, family = 0x01`
**Общее назначение:** байтовые и message-потоки для I/O, событий и интеграции с внешними шинами.

**Варианты:**

1. `KindId(0x01, 0x01, 0x0001) — stream.inproc`
   *Внутрипроцессный поток (каналы между run-ами в том же процессе).*

   * Юзкейсы: шина событий между run-ами одного узла, быстрые пайпы между модулями аналитики, отладочные каналы.
   * Свойства: низкая задержка, отсутствует сетевой стек, память процесса.

2. `KindId(0x01, 0x01, 0x0002) — stream.ipc`
   *Межпроцессный поток (локальные сокеты, pipe, shared memory).*

   * Юзкейсы: взаимодействие `zb`-узла с локальными демонами, вспомогательными сервисами, sidecar-процессами.
   * Свойства: ограниченная локальной машиной, без маршрутизации.

3. `KindId(0x01, 0x01, 0x0003) — stream.tcp`
   *TCP-соединения.*

   * Юзкейсы: клиент-серверные протоколы, двоичные RPC, интеграция с внешними брокерами.
   * Свойства: надёжный поток байтов, порядок доставки гарантирован.

4. `KindId(0x01, 0x01, 0x0004) — stream.udp`
   *UDP-поток.*

   * Юзкейсы: телеметрия, датаграммы, потоковые обновления без жестких гарантий, мультикаст.
   * Свойства: без гарантии доставки/порядка, минимальные накладные расходы.

5. `KindId(0x01, 0x01, 0x0005) — stream.quic`
   *QUIC-поток.*

   * Юзкейсы: низкая задержка + шифрование + мультиплексирование, веб-клиенты, mobile.
   * Свойства: UDP-основа, надёжные и ненадёжные субпотоки.

6. `KindId(0x01, 0x01, 0x0006) — stream.ws`
   *WebSocket-поток.*

   * Юзкейсы: браузер ↔ ZeroBus, живые UI, push-уведомления.
   * Свойства: текст/бинар, поверх HTTP(S).

7. `KindId(0x01, 0x01, 0x0007) — stream.mqtt`
   *Поток через брокер MQTT.*

   * Юзкейсы: IoT, сенсоры, устройства с нестабильной связью, pub/sub.

8. `KindId(0x01, 0x01, 0x0008) — stream.kafka`
   *Поток с Kafka-подобным брокером.*

   * Юзкейсы: батч/стрим-аналитика, логирование, интеграция с существующей Kafka-инфраструктурой.

9. `KindId(0x01, 0x01, 0x0009) — stream.rng_hw`
   *Поток криптографически стойких случайных байтов от аппаратного генератора.*

   * Юзкейсы: генерация ключей, nonce, криптопримитивы с сильной энтропией.

10. `KindId(0x01, 0x01, 0x000A) — stream.rng_sw`
    *Поток псевдослучайных байтов от детерминированного генератора.*

    * Юзкейсы: детерминированные симуляции, тесты, воспроизводимые эксперименты.
    * Свойства: управляемый seed, подчёркнутая детерминированность.

11. `KindId(0x01, 0x01, 0x000B) — stream.clock`
    *Поток временных событий (тикеры/таймеры).*

    * Юзкейсы: cron-подобные задачи, тайм-ауты, периодический запуск run-ов.

12. `KindId(0x01, 0x01, 0x000C) — stream.task`
    *Поток событий и статусов run-ов.*

    * Юзкейсы: мониторинг, внешние оркестраторы, “внешний AQL” для наблюдения за ядром.

---

#### 5.1.3. Семейство 0x02 — BLOCK (блочные устройства)

**Назначение:** абстракция блочного I/O (файлы, диски, псевдоустройства).

**Варианты:**

1. `KindId(0x01, 0x02, 0x0001) — block.file`
   *Файлы на ФС хоста.*

   * Юзкейсы: WAL-файлы, снапшоты индексов, временные сегменты.
   * Свойства: POSIX-подобная семантика, операции `open/close/read/write/fsync`.

2. `KindId(0x01, 0x02, 0x0002) — block.device`
   *Сырые блочные устройства (диски, разделы).*

   * Юзкейсы: высокопроизводительные журналы, собственные форматы поверх “сырого” диска.
   * Требование: аккуратное использование, ответственность за layout на стороне примитива.

3. `KindId(0x01, 0x02, 0x0003) — block.memory`
   *In-memory блочные области.*

   * Юзкейсы: тесты алгоритмов WAL/индексов, временные структуры без durable-гарантий.
   * Свойства: volatile, быстрый, ограниченный памятью процесса.

---

#### 5.1.4. Семейство 0x03 — BLOB (объектные/KV-хранилища)

**Назначение:** key–value и объектные хранилища, видимые как логический “blob-store”.

**Варианты:**

1. `KindId(0x01, 0x03, 0x0001) — blob.ram`
   *Оперативное KV-хранилище.*

   * Юзкейсы: конфигурации, кэш, временные метаданные, состояния сессий.

2. `KindId(0x01, 0x03, 0x0002) — blob.fs`
   *KV поверх каталогов/файлов.*

   * Юзкейсы: небольшие справочники, локальные коллекции документов, легковесные метаданные узла.

3. `KindId(0x01, 0x03, 0x0003) — blob.s3`
   *S3-совместимое хранилище.*

   * Юзкейсы: архивы, большие лог-файлы, модели ML, снапшоты в облаке.

4. `KindId(0x01, 0x03, 0x0004) — blob.redis`
   *Redis-подобное сетевое KV.*

   * Юзкейсы: распределённые кэши, обмен состоянием между узлами, простые очереди.

5. `KindId(0x01, 0x03, 0x0005) — blob.grant`
   *Хранилище грантов и политик доступа.*

   * Юзкейсы: ZBAC-политики, ACL, мэппинг субъектов к правам.

6. `KindId(0x01, 0x03, 0x0006) — blob.id`
   *Хранилище идентичностей и ключей.*

   * Юзкейсы: ключи узлов, пользователей, сертификаты, токены.

7. `KindId(0x01, 0x03, 0x0007) — blob.timer`
   *Хранилище таймеров/отложенных событий.*

   * Юзкейсы: планирование задач, отложенные run-ы, напоминания.

---

#### 5.1.5. Семейство 0x10 — UI_INPUT

**Назначение:** источники событий ввода для UI-профиля (`ZDK.UI`, `ZDK.Web`).

**Варианты:**

1. `KindId(0x01, 0x10, 0x0001) — ui.input.keyboard`
   *Клавиатура.*

2. `KindId(0x01, 0x10, 0x0002) — ui.input.pointer`
   *Мышь/тач/стилус (позиция, кнопки).*

3. `KindId(0x01, 0x10, 0x0003) — ui.input.wheel`
   *Колесо прокрутки.*

4. `KindId(0x01, 0x10, 0x0004) — ui.input.gamepad`
   *Геймпады, джойстики.*

5. `KindId(0x01, 0x10, 0x0005) — ui.input.sensor`
   *Датчики движения, ориентации, прочие сенсоры.*

Юзкейсы: интерактивные панели админки `zb`, кастомные UI-фронты поверх ZeroBus, браузерные клиенты.

---

#### 5.1.6. Семейство 0x11 — UI_SURFACE

**Назначение:** поверхности рендера (targets для 2D/3D-рисования).

**Варианты:**

1. `KindId(0x01, 0x11, 0x0001) — ui.surface.main`
   *Основная поверхность приложения (главное окно / canvas).*

2. `KindId(0x01, 0x11, 0x0002) — ui.surface.overlay`
   *Оверлеи, всплывающие панели, HUD.*

3. `KindId(0x01, 0x11, 0x0003) — ui.surface.offscreen`
   *Offscreen-буферы для композитинга, кэша, эффектов.*

---

#### 5.1.7. Семейство 0x12 — UI_MEDIA

**Назначение:** аудио/видео драйверы.

**Варианты:**

1. `KindId(0x01, 0x12, 0x0001) — ui.media.audio_out`
   *Воспроизведение аудио.*

2. `KindId(0x01, 0x12, 0x0002) — ui.media.audio_in`
   *Захват аудио (микрофон и др.).*

3. `KindId(0x01, 0x12, 0x0003) — ui.media.video_in`
   *Захват видео (камера, экран).*

---

#### 5.1.8. Семейство 0x13 — STORAGE_WEB

**Назначение:** web-специфичные хранилища браузера.

**Варианты:**

1. `KindId(0x01, 0x13, 0x0001) — storage.web.local`
   *localStorage.*

2. `KindId(0x01, 0x13, 0x0002) — storage.web.session`
   *sessionStorage.*

3. `KindId(0x01, 0x13, 0x0003) — storage.web.idb`
   *IndexedDB.*

Юзкейсы: оффлайн-состояния UI, кэш фронта, локальные настройки пользователя.

---

### 5.2. Класс 0x02 — STATE_ALGO

5.2.1. **Общие положения**

Класс `STATE_ALGO` описывает **алгоритмические примитивы состояния**:

* индексы и структуры данных;
* скетчи и агрегаторы;
* модели, прогнозы, риск-функции;
* политики и контроллеры;
* UI-состояние.

Именно эти примитивы связывают:

* потоки событий (`EMIT`),
* операции чтения (`SCAN`),
* и внутреннее состояние Run’а (`state`).

---

#### 5.2.2. Семейство 0x01 — INDEX (индексы)

**Назначение:** структуры для ускорения поиска и фильтрации.

**Типичные EMIT/SCAN:**

* `emit.reduce` — вставка/удаление ключей, обновление метаданных;
* `scan.*` — range/prefix/point запросы, полнотекстовый поиск.

**Варианты:**

1. `KindId(0x02, 0x01, 0x0001) — index.hash`
   *Хеш-словарь (ключ → значение/offset).*

   * Юзкейсы: быстрый точечный поиск по ключу, lookup таблиц, кэш.

2. `KindId(0x02, 0x01, 0x0002) — index.btree`
   *Упорядоченный индекс (B/B+ дерево).*

   * Юзкейсы: range-запросы по времени/диапазону значений, вторичные индексы.

3. `KindId(0x02, 0x01, 0x0003) — index.roaring`
   *Bitmap-индекс (Roaring).*

   * Юзкейсы: фильтрация по множеству флагов/ID, аналитика логов, быстрые set-операции.

4. `KindId(0x02, 0x01, 0x0004) — index.trigram`
   *3-граммный индекс строк.*

   * Юзкейсы: LIKE/substring-поиск, подсказки, поиск по логам.

5. `KindId(0x02, 0x01, 0x0005) — index.interval`
   *Индекс интервалов (interval tree).*

   * Юзкейсы: расписания, бронирования, временные окна, конфликты.

6. `KindId(0x02, 0x01, 0x0006) — index.zone_map`
   *Zone map по блокам.*

   * Юзкейсы: столбцовые хранилища, быстрый skip блоков по min/max-статистике.

7. `KindId(0x02, 0x01, 0x0007) — index.string_dict`
   *Словарь строк (строка → small-id).*

   * Юзкейсы: нормализация категориальных признаков, кодировки для ANN/ML.

8. `KindId(0x02, 0x01, 0x0008) — index.label_map`
   *Label → множество ID.*

   * Юзкейсы: тегирование объектов, обратные ссылки.

9. `KindId(0x02, 0x01, 0x0009) — index.fm_index`
   *Компактный полнотекстовый индекс (FM).*

   * Юзкейсы: эффективный full-text поиск по большим корпусам.

10. `KindId(0x02, 0x01, 0x000A) — index.cuckoo`
    *Cuckoo hash.*

    * Юзкейсы: компактные словари с предсказуемой латентностью lookup.

11. `KindId(0x02, 0x01, 0x000B) — index.quotient`
    *Quotient filter.*

    * Юзкейсы: фильтр принадлежности с возможностью удаления, альтернатива Bloom.

12. `KindId(0x02, 0x01, 0x000C) — index.bloomier`
    *Bloomier filter (ассоциативный массив на основе Bloom-структуры).*

    * Юзкейсы: компактные справочники “ключ → маленькое значение” в памяти.

---

#### 5.2.3. Семейство 0x02 — SKETCH (стриминговые скетчи)

**Назначение:** приближённые агрегаты по потокам, ориентированные на **частоты и heavy hitters**.

**Варианты:**

1. `KindId(0x02, 0x02, 0x0001) — sketch.count_min`
   *Count-Min Sketch.*

   * Юзкейсы: частоты ключей, топы по логам/событиям, детекция аномально популярных ключей.

2. `KindId(0x02, 0x02, 0x0002) — sketch.count_sketch`
   *Count Sketch.*

   * Юзкейсы: приближённая корреляция, heavy hitters при наличии шумных данных.

3. `KindId(0x02, 0x02, 0x0003) — sketch.heavy_guard`
   *Варианты heavy-guarding heavy hitters.*

   * Юзкейсы: топ-пользователи, топ-URL, top-N по нагрузке.

---

#### 5.2.4. Семейство 0x03 — DISTINCT (уникальность)

**Назначение:** приближённый подсчёт числа различных значений.

**Варианты:**

1. `KindId(0x02, 0x03, 0x0001) — distinct.hll`
   *HyperLogLog.*

   * Юзкейсы: уникальные пользователи, уникальные ключи, оценка кардинальности больших множеств.

2. `KindId(0x02, 0x03, 0x0002) — distinct.kmv`
   *K-Minimum Values.*

   * Юзкейсы: оценки кардинальности по подмножествам, объединения/пересечения.

3. `KindId(0x02, 0x03, 0x0003) — distinct.theta`
   *Theta-sketch.*

   * Юзкейсы: гибкие оперции объединения/пересечения/разности множеств с оценкой размера.

---

#### 5.2.5. Семейство 0x04 — QUANTILE (квантили и распределения)

**Назначение:** приближённое воспроизведение распределения значений.

**Варианты:**

1. `KindId(0x02, 0x04, 0x0001) — quantile.histogram`
   *Гистограмма с адаптивными/фиксированными бинами.*

   * Юзкейсы: latency SLA, распределение откликов, аналитику задержек.

2. `KindId(0x02, 0x04, 0x0002) — quantile.tdigest`
   *t-digest.*

   * Юзкейсы: точные хвостовые квантили (p99/p999) для latency и финансовых рисков.

3. `KindId(0x02, 0x04, 0x0003) — quantile.ddsketch`
   *DDSketch.*

   * Юзкейсы: масштабируемые квантильные оценки с контролируемой относительной ошибкой.

4. `KindId(0x02, 0x04, 0x0004) — quantile.gk`
   *Greenwald–Khanna.*

   * Юзкейсы: строгие гарантии по (\epsilon) для квантилей в потоках.

---

#### 5.2.6. Семейство 0x05 — WINDOW (оконные агрегаты)

**Назначение:** агрегаты на скользящих/экспоненциальных окнах.

**Варианты:**

1. `KindId(0x02, 0x05, 0x0001) — window.ewma`
   *Экспоненциально взвешенное среднее (EWMA).*

   * Юзкейсы: сглаженная волатильность, тренды, метрики нагрузки.

2. `KindId(0x02, 0x05, 0x0002) — window.sliding_count`
   *Скользящее окно с подсчётом.*

   * Юзкейсы: rate-лимиты, RPS/ops, алерты на всплески.

3. `KindId(0x02, 0x05, 0x0003) — window.reservoir`
   *Reservoir sampling.*

   * Юзкейсы: репрезентативные выборки из больших потоков без хранения всего.

---

#### 5.2.7. Семейство 0x06 — TEXT

**Назначение:** алгоритмы текстового поиска и соответствий.

**Варианты:**

1. `KindId(0x02, 0x06, 0x0001) — text.aho_corasick`
   *Aho–Corasick автомат.*

   * Юзкейсы: множественный поиск шаблонов (фильтрация запросов, сигнатуры атак).

2. `KindId(0x02, 0x06, 0x0002) — text.fst_dict`
   *FST-словарь (Finite State Transducer).*

   * Юзкейсы: сжатый словарь лексем, автодополнение, map строк → id.

---

#### 5.2.8. Семейство 0x07 — SIMILARITY

**Назначение:** приблизительные проверки схожести.

**Варианты:**

1. `KindId(0x02, 0x07, 0x0001) — sim.minhash`
   *MinHash.*

   * Юзкейсы: схожесть множеств (документы, профили).

2. `KindId(0x02, 0x07, 0x0002) — sim.simhash`
   *SimHash.*

   * Юзкейсы: почти-одинаковые документы, near-duplicate detection.

3. `KindId(0x02, 0x07, 0x0003) — sim.lsh`
   *Обобщённые LSH-схемы.*

   * Юзкейсы: быстрый approximate search по признаковым векторам.

---

#### 5.2.9. Семейство 0x08 — ANN (Approximate Nearest Neighbors)

**Назначение:** поиск ближайших соседей в больших векторных пространствах.

**Варианты:**

1. `KindId(0x02, 0x08, 0x0001) — ann.hnsw`
   *HNSW-графы.*

2. `KindId(0x02, 0x08, 0x0002) — ann.ivf_flat`
   *IVF flat.*

3. `KindId(0x02, 0x08, 0x0003) — ann.ivf_pq`
   *IVF + PQ.*

4. `KindId(0x02, 0x08, 0x0004) — ann.opq`
   *Оптимальный product quantization.*

Юзкейсы: эмбеддинги пользователей, поиск по семантике, рекомендации.

---

#### 5.2.10. Семейство 0x09 — SPATIAL

**Назначение:** пространственные индексы.

**Варианты:**

1. `KindId(0x02, 0x09, 0x0001) — spatial.rtree`
   *R-дерево.*

2. `KindId(0x02, 0x09, 0x0002) — spatial.kdtree`
   *KD-дерево.*

3. `KindId(0x02, 0x09, 0x0003) — spatial.quadtree`
   *Quadtree.*

4. `KindId(0x02, 0x09, 0x0004) — spatial.zorder`
   *Z-order / Morton кодирование.*

Юзкейсы: гео-запросы, коллизии в симуляциях, layout UI/графики.

---

#### 5.2.11. Семейство 0x0A — TIMESERIES

**Назначение:** структуры для работы с временными рядами.

**Варианты:**

1. `KindId(0x02, 0x0A, 0x0001) — ts.segment_tree`
   *Segment tree.*

2. `KindId(0x02, 0x0A, 0x0002) — ts.fenwick`
   *Fenwick tree.*

3. `KindId(0x02, 0x0A, 0x0003) — ts.ring_buffer`
   *Кольцевой буфер временных точек.*

4. `KindId(0x02, 0x0A, 0x0004) — ts.block_agg`
   *Агрегаты по блокам (time-bucketed).*

Юзкейсы: агрегаты по времени, скользящие метрики, хранение котировок/логов.

---

#### 5.2.12. Семейство 0x0B — GRAPH

**Назначение:** потоковые и оффлайн-алгоритмы графов.

**Варианты:**

1. `KindId(0x02, 0x0B, 0x0001) — graph.degree`
   *Степени, распределение степеней.*

2. `KindId(0x02, 0x0B, 0x0002) — graph.triangles`
   *Подсчёт треугольников/кластеризация.*

3. `KindId(0x02, 0x0B, 0x0003) — graph.pagerank`
   *PageRank и его вариации.*

Юзкейсы: социальные графы, графы переходов, анализ структуры связей.

---

#### 5.2.13. Семейство 0x0C — LINALG

**Назначение:** линейная алгебра и приближённые матричные методы.

**Варианты:**

1. `KindId(0x02, 0x0C, 0x0001) — linalg.frequent_directions`
   *Frequent Directions.*

2. `KindId(0x02, 0x0C, 0x0002) — linalg.rand_proj`
   *Random projection.*

3. `KindId(0x02, 0x0C, 0x0003) — linalg.pca_approx`
   *Приближённый PCA.*

Юзкейсы: сжатие признаков, построение эмбеддингов, подготовка к ANN.

---

#### 5.2.14. Семейство 0x0D — CRDT

**Назначение:** структуры для реплицируемого/конфликтно-устойчивого состояния.

**Варианты:**

1. `KindId(0x02, 0x0D, 0x0001) — crdt.pn_counter`
   *PN-счётчик.*

2. `KindId(0x02, 0x0D, 0x0002) — crdt.or_set`
   *Observed-Remove set.*

3. `KindId(0x02, 0x0D, 0x0003) — crdt.lww_reg`
   *Last-Writer-Wins регистр.*

4. `KindId(0x02, 0x0D, 0x0004) — crdt.map`
   *CRDT-карта.*

Юзкейсы: распределённые настройки, коллаборативные документы, shared state.

---

#### 5.2.15. Семейство 0x0E — RECON (согласование множеств)

**Назначение:** согласование состояний между узлами по неполному каналу.

**Варианты:**

1. `KindId(0x02, 0x0E, 0x0001) — recon.iblt`
   *Invertible Bloom Lookup Table.*

2. `KindId(0x02, 0x0E, 0x0002) — recon.set_sync`
   *Общие схемы согласования множеств.*

Юзкейсы: синхронизация WAL-сегментов, различий в индексах, обмен “diff” между нодами.

---

#### 5.2.16. Семейство 0x0F — MODEL (модели `y = f(x; θ)`)

**Назначение:** параметрические модели, применяемые к признакам.

**Типичный контракт:**

* `emit.reduce` — обновление параметров `θ` по примерам `(x, y)` или градиентам;
* `scan.read` — вычисление `ŷ = f(x; θ)` для входного признакового вектора.

**Варианты:**

1. `KindId(0x02, 0x0F, 0x0001) — model.linear_reg`
   *Линейная регрессия.*

2. `KindId(0x02, 0x0F, 0x0002) — model.logistic_reg`
   *Логистическая регрессия (классификация).*

3. `KindId(0x02, 0x0F, 0x0003) — model.glm`
   *Общая линейная модель.*

4. `KindId(0x02, 0x0F, 0x0004) — model.tree_simple`
   *Простое дерево решений/стамп.*

5. `KindId(0x02, 0x0F, 0x0005) — model.nn_small`
   *Маленькая MLP с фиксированной топологией.*

Юзкейсы: скоринг событий, оценка интенсивностей, прогнозы параметров (например, λ(δ) в маркет-мейкинге).

---

#### 5.2.17. Семейство 0x10 — WAL

**Назначение:** примитивы журнала узла.

**Варианты:**

1. `KindId(0x02, 0x10, 0x0001) — wal.segmented`
   *Сегментированный журнал.*

   * Юзкейсы: записываемые события Run’ов, репликация, реплей.

Дополнительные варианты (например, `wal.lsm`, `wal.append_only`) могут добавляться в будущих минорных версиях.

---

#### 5.2.18. Семейство 0x11 — RISK (риск-функции и utility)

**Назначение:** вычисление функционалов риска и полезности по P&L, инвентарю, метрикам.

**Варианты:**

1. `KindId(0x02, 0x11, 0x0001) — risk.var`
   *Value-at-Risk.*

2. `KindId(0x02, 0x11, 0x0002) — risk.cvar`
   *Conditional VaR (Expected Shortfall).*

3. `KindId(0x02, 0x11, 0x0003) — risk.entropic`
   *Экспоненциальная utility-функция.*

4. `KindId(0x02, 0x11, 0x0004) — risk.drawdown`
   *Метрики max drawdown.*

5. `KindId(0x02, 0x11, 0x0005) — risk.inventory_penalty`
   *Штрафы за отклонение инвентаря от целевых уровней.*

Юзкейсы: риск-менеджмент стратегий (включая HFT/маркет-мейкеров), лимиты, алерты.

---

#### 5.2.19. Семейство 0x12 — OPT (оптимизация параметров)

**Назначение:** онлайн/оффлайн оптимизация параметров моделей или политик.

**Варианты:**

1. `KindId(0x02, 0x12, 0x0001) — opt.sgd`
   *Stochastic Gradient Descent.*

2. `KindId(0x02, 0x12, 0x0002) — opt.adam`
   *Adam / AdamW.*

3. `KindId(0x02, 0x12, 0x0003) — opt.nelder_mead`
   *Nelder–Mead (безградиентный).*

4. `KindId(0x02, 0x12, 0x0004) — opt.cma_es`
   *CMA-ES.*

Юзкейсы: калибровка стратегий, найстройка параметров risk- и control-примитивов.

---

#### 5.2.20. Семейство 0x13 — FORECAST_TS (прогноз временных рядов)

**Назначение:** модели прогноза по временным рядам.

**Варианты:**

1. `KindId(0x02, 0x13, 0x0001) — tsf.ar`
   *Autoregressive (AR).*

2. `KindId(0x02, 0x13, 0x0002) — tsf.arima`
   *ARIMA.*

3. `KindId(0x02, 0x13, 0x0003) — tsf.kalman`
   *Линейная state-space модель с фильтром Калмана.*

4. `KindId(0x02, 0x13, 0x0004) — tsf.ewma_vol`
   *EWMA-волатильность.*

5. `KindId(0x02, 0x13, 0x0005) — tsf.regime`
   *Простейшие переключающиеся режимы (low/high volatility и т.п.).*

Юзкейсы: прогноз цен, волатильности, нагрузок, arrival rates.

---

#### 5.2.21. Семейство 0x14 — CONTROL (политики `state → action`)

**Назначение:** контроллеры и политики, принимающие решения по состоянию.

**Типичный контракт:**

* вход: признаки состояния (вектор `s_t`);
* выход: действие/команда (например, параметры ордера, конфигурации, включение/выключение run-ов).

**Варианты:**

1. `KindId(0x02, 0x14, 0x0001) — control.table`
   *Табличная политика (дискретное state → action).*

2. `KindId(0x02, 0x14, 0x0002) — control.linear`
   *Линейная/аффинная политика.*

3. `KindId(0x02, 0x14, 0x0003) — control.tree`
   *Дерево решений.*

4. `KindId(0x02, 0x14, 0x0004) — control.bandit`
   *Multi-armed bandit политика (UCB/Thompson и др.).*

5. `KindId(0x02, 0x14, 0x0005) — control.mm_quote_avellaneda_v1`
   *Референсная политика маркет-мейкинга в духе Avellaneda–Stoikov: выдаёт параметры bid/ask по состоянию (цена, инвентарь, σ̂, λ̂, горизонт).*

Юзкейсы: HFT-боты, throttle-контроллеры, адаптивные UI-политики.

---

#### 5.2.22. Семейство 0x15 — RL_AGENT (агенты обучения с подкреплением)

**Назначение:** более сложные агенты RL поверх CONTROL/MODEL/RISK.

**Варианты (минимальный ядро):**

1. `KindId(0x02, 0x15, 0x0001) — rl.bandit`
   *Бандитный агент (contextual bandits).*

2. `KindId(0x02, 0x15, 0x0002) — rl.q_learning`
   *Q-learning/табличные агенты.*

3. `KindId(0x02, 0x15, 0x0003) — rl.actor_critic`
   *Базовый actor–critic.*

Юзкейсы: адаптивные стратегии, авто-тюнинг параметров ZeroBus-узла под среду.

---

#### 5.2.23. Семейство 0x20 — UI_FRAME2D

**Назначение:** буфер команд для 2D-рендера (IMGUI-подобная модель).

**Вариант:**

1. `KindId(0x02, 0x20, 0x0001) — ui.frame2d.cmd_stream`
   *Поток команд: BeginFrame/EndFrame, DrawRect, DrawImage, DrawText, PushClip, PushTransform и т.п.*

---

#### 5.2.24. Семейство 0x21 — UI_LAYOUT

**Назначение:** алгоритмы раскладки.

**Варианты:**

1. `KindId(0x02, 0x21, 0x0001) — ui.layout.stack`
   *Вертикальный/горизонтальный stack.*

2. `KindId(0x02, 0x21, 0x0002) — ui.layout.flex`
   *Flexbox-подобный layout.*

3. `KindId(0x02, 0x21, 0x0003) — ui.layout.grid`
   *Grid-сетка.*

---

#### 5.2.25. Семейство 0x22 — UI_WIDGET

**Назначение:** состояние виджетов и маршрутизация событий.

**Варианты:**

1. `KindId(0x02, 0x22, 0x0001) — ui.widget.tree`
   *Дерево виджетов.*

2. `KindId(0x02, 0x22, 0x0002) — ui.widget.focus`
   *Фокус/активные элементы.*

3. `KindId(0x02, 0x22, 0x0003) — ui.widget.hit_test`
   *Hit-testing для событий ввода.*

---

#### 5.2.26. Семейство 0x23 — UI_TEXT

**Назначение:** текстовый layout и шейпинг.

**Варианты:**

1. `KindId(0x02, 0x23, 0x0001) — ui.text.shaper`
   *Шейпинг глифов.*

2. `KindId(0x02, 0x23, 0x0002) — ui.text.line_break`
   *Переносы строк.*

3. `KindId(0x02, 0x23, 0x0003) — ui.text.cache`
   *Кэш глифов/текстур.*

---

#### 5.2.27. Семейство 0x24 — UI_THEME

**Назначение:** темы/стили.

**Варианты:**

1. `KindId(0x02, 0x24, 0x0001) — ui.theme.palette`
   *Цветовые палитры.*

2. `KindId(0x02, 0x24, 0x0002) — ui.theme.metrics`
   *Размеры, отступы, радиусы.*

3. `KindId(0x02, 0x24, 0x0003) — ui.theme.typography`
   *Шрифты, размеры текста.*

---

### 5.3. Класс 0x03 — SCAN_META

5.3.1. **Общие положения**

Класс `SCAN_META` задаёт **метаданные операций SCAN**:

* откуда читаем (`SOURCE`),
* как читаем (`MODE`),
* в каком виде возвращаем (`RESULT`).

Эти KindId не несут данных сами по себе, а описывают форму/режим доступа к STATE_ALGO/ WAL/индексам.

---

#### 5.3.2. Семейство 0x01 — SOURCE (источники)

**Варианты:**

1. `KindId(0x03, 0x01, 0x0001) — scan.source.wal`
   *Чтение из WAL.*

2. `KindId(0x03, 0x01, 0x0002) — scan.source.index`
   *Чтение через индекс INDEX.*.

3. `KindId(0x03, 0x01, 0x0003) — scan.source.state_algo`
   *Чтение состояния STATE_ALGO-примитивов.*

4. `KindId(0x03, 0x01, 0x0004) — scan.source.blob`
   *Чтение из BLOB-хранилищ.*

5. `KindId(0x03, 0x01, 0x0005) — scan.source.host_stream`
   *Чтение из HOST_DEV.stream.* в режиме “streaming scan”.*

---

#### 5.3.3. Семейство 0x02 — MODE (режимы сканирования)

**Варианты:**

1. `KindId(0x03, 0x02, 0x0001) — scan.mode.seq`
   *Последовательный проход.*

2. `KindId(0x03, 0x02, 0x0002) — scan.mode.range`
   *Диапазон (по ключу/времени/метке).*

3. `KindId(0x03, 0x02, 0x0003) — scan.mode.prefix`
   *Prefix-запросы (по префиксу ключа).*

4. `KindId(0x03, 0x02, 0x0004) — scan.mode.point`
   *Точечный запрос.*

5. `KindId(0x03, 0x02, 0x0005) — scan.mode.knn`
   *Поиск ближайших соседей (ANN/SPATIAL).*

6. `KindId(0x03, 0x02, 0x0006) — scan.mode.bitmap`
   *Возврат bitmap/битовых масок.*

7. `KindId(0x03, 0x02, 0x0007) — scan.mode.agg`
   *Агрегирующие сканы (суммы, квантили и т.п.).*

---

#### 5.3.4. Семейство 0x03 — RESULT (форма результата)

**Варианты:**

1. `KindId(0x03, 0x03, 0x0001) — scan.result.rows`
   *Набор строк/записей (row-oriented).*

2. `KindId(0x03, 0x03, 0x0002) — scan.result.columnar`
   *Колончатое представление.*

3. `KindId(0x03, 0x03, 0x0003) — scan.result.scalar`
   *Скаляр (одна величина).*

4. `KindId(0x03, 0x03, 0x0004) — scan.result.offset_len`
   *Пары `(offset, length)` в WAL/блоках.*

5. `KindId(0x03, 0x03, 0x0005) — scan.result.tagged`
   *Помеченные результаты (tag → payload).*

---

Раздел 5 в такой редакции задаёт **полный и детализированный каталог классов, семейств и ключевых вариантов алгоритмов ZDK v1**, достаточный, чтобы:

* описывать любые data-plane задачи (индексы, скетчи, WAL);
* строить analytical/ML/forecasting-пайплайны (MODEL, RISK, OPT, FORECAST_TS);
* реализовывать decision-making и стратегии (CONTROL, RL_AGENT);
* описывать UI и браузерный профиль (UI_* в HOST_DEV и STATE_ALGO);
* унифицировать все виды SCAN-операций через SCAN_META.


---

## 6. Модель работы ZDK с примитивами

6.1. **Общая идея**

С точки зрения хост-разработчика ZDK предоставляет:

* **типизированный API**, опирающийся на KindId и профили;
* **сильную типизацию конфигураций** (структуры под каждый KindId);
* **унифицированные вызовы** к Host Gateway, скрывающие бинарный протокол.

Всё, что происходит дальше, — внутренняя работа ZRK.

6.2. **Хост-обвязки (языковые SDK)**

Для каждого поддерживаемого языка ZDK предоставляет:

* тип `KindId` и перечисления для известных классов/семейств/вариантов;
* структуры конфигураций (например, `StreamConfig`, `BlobConfig`, `IndexConfig`, `UiFrame2dConfig`);
* типы запросов/ответов Host Gateway:

  * «создать/закрыть/переконфигурировать примитив»;
  * «инициировать run»;
  * «выполнить шаг emit/scan» и т.п.

SDK **не раскрывает** внутренних типов ядра ZRK, а работает на уровне этих структур и KindId.

6.3. **Единый подход к взаимодействию**

Независимо от платформы:

* серверное приложение, использующее ZeroBus;
* утилита администратора/наблюдения;
* браузерное приложение (через WASM-ядро);
* встроенная система (через встраиваемый runtime ZRK);

— получают один и тот же логический API:

1. Выбрать KindId интересующего примитива.
2. Сформировать конфигурацию/запрос в структурах SDK.
3. Отправить запрос в Host Gateway (через ZDK-обёртку).
4. Обработать ответ, включая возможные изменения состояний/кодов (согласно ZRK).

---

## 7. Профили ZDK

### 7.1. Профиль `ZDK.Core`

Минимальный профиль, доступный в community-версии и достаточный для:

* записей в WAL;
* построения базовых индексов;
* работы с blob-хранилищами и потоками;

Включает:

* HOST_DEV:

  * `stream.inproc`, `stream.tcp/ws` (минимальный набор),
  * `block.file`,
  * `blob.ram`, `blob.fs`, базовый `blob.s3`/`blob.redis`.
* STATE_ALGO:

  * основные INDEX (hash/btree/roaring/bloom),
  * базовые скетчи (счётчики, HLL),
  * WAL.
* SCAN_META:

  * базовые источники и режимы (SEQ, RANGE, PREFIX, POINT, AGG).

Оптимизированные или продвинутые алгоритмы (ANN, сложные CRDT, продвинутые скетчи) могут относиться к premium, сохраняя те же KindId.

### 7.2. Профиль `ZDK.UI` (premium)

Расширяет `ZDK.Core`:

* HOST_DEV:

  * `ui.input.*`, `ui.surface.*`, `ui.media.*`, `storage.web.*`.
* STATE_ALGO:

  * `ui.frame2d.*`, `ui.layout.*`, `ui.widget.*`, `ui.text.*`, `ui.theme.*`.

Предназначен для построения интерфейсов пользователя (браузер/нативно) полностью на основе Run/KindId-модели. Реализации UI-примитивов и рендеринга относятся к закрытой части и активируются лицензионными грантами.

### 7.3. Профиль `ZDK.Web`

Конкретизация `ZDK.UI` для браузерной среды:

* ядро ZRK поставляется как WASM-модуль;
* JS-обвязка маппит Web APIs:

  * DOM-события → `ui.input.*`;
  * Canvas/WebGL/WebGPU → `ui.surface.*`;
  * WebAudio/getUserMedia → `ui.media.*`;
  * localStorage/sessionStorage/IndexedDB → `storage.web.*`.

С точки зрения ZDK, это лишь конкретный носитель для тех же KindId и тех же логических примитивов.

---

## 8. Расширяемость и совместимость

8.1. **Добавление новых примитивов**

* Новые KindId могут добавляться:

  * в существующие классы/семейства;
  * в новые классы/семейства, добавленные ZDK v1.x.
* При этом необходимо:

  * не переиспользовать уже занятые `(class, family, variant)`;
  * описать семантику нового примитива в терминах ZRK и Host Gateway.

8.2. **Изменение существующих примитивов**

* Изменение семантики уже выпущенного KindId (поведение, контракт, тип конфигурации) требует:

  * объявления новой major-версии ZDK (v2 и далее);
  * либо выделения нового KindId, если необходима параллельная поддержка старого и нового поведения.

8.3. **Сторонние расширения**

* Пользовательские/партнёрские реализации могут использовать зарезервированные диапазоны `variant` (например, `0x8000+`) внутри существующих `class`/`family`.
* Такие расширения не должны конфликтовать с официальным реестром ZDK и обязаны соблюдать базовые инварианты ZRK.

---

Эта спецификация ZDK v1 фиксирует:

* как ZRK-ядро встраивается в окружение (только рядом, только через HOST);
* как все примитивы ZeroBus классифицируются в терминах KindId;
* какие профили и наборы примитивов доступны в открытом и премиум-режимах.

Всё остальное — уже вопрос реализации, производительности и красоты, но геометрия системы от этого не меняется.
