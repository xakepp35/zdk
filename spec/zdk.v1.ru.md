# Спецификация ZeroBus Development Kit (ZDK)

```spec
File:   spec/zdk.v1.ru.md
Owner:  xakepp35
Version: v1.0.0
Updated: 2025-11-16
License: Apache 2.0
Depends: spec/zrk.v1.ru.md
```

## 1. Область действия, цели и назначение

1.1. Настоящая спецификация определяет **ZeroBus Development Kit (ZDK)** — открытый каталог классов, семейств и примитивов ZeroBus, а также единый формат работы с ними на стороне хоста.

1.2. Спецификация ZDK **опирается на модель ядра**, определённую в документе **ZeroBus Run Kernel (ZRK)**:

* понятия `Run`, `RunId`, `space`, `state`, `code`;
* четыре пространства исполнения: `HOST`, `EMIT`, `SCAN`, `TASK`;
* минимальный набор ABI-функций ядра.

Настоящий документ **не повторяет** эти определения и использует термины ZRK без повторных пояснений.

1.3. ZDK устанавливает:

* структуру 32-битного идентификатора примитива (**KindId**) и правила его использования;
* реестр классов (`class`), семейств (`family`) и вариантов (`variant`) примитивов;
* абстрактную модель взаимодействия хост-процесса с ядром ZRK через плоскость `HOST`;
* профили ZDK (Core/UI/Web) и состав примитивов, входящих в каждый профиль.

1.4. ZDK **не описывает**:

* внутренние алгоритмы реализации ZRK;
* внутренний формат исполнений (Rust-бинарь, WASM-модуль) и криптографические детали упаковки;
* конкретный бинарный протокол обмена между хостом и ядром (линейное представление сообщений, выравнивание, endianess).

Все такие детали являются внутренними для реализации и могут изменяться при сохранении описанных ниже контрактов.

---

## 2. Лицензирование, открытость и состав поставки

2.1. **Открытая часть (репозиторий ZDK)**

* Все файлы в репозитории `zdk` (спеки, заголовки, описания форматов, справочники и схемы) лицензируются под **Apache 2.0**.
* Открытая часть включает:

  * настоящую спецификацию ZDK;
  * реестр KindId (классы, семейства, варианты);
  * текстовые описания примитивов и их семантики;
  * открытые SDK-обвязки для языков (Rust/Go/TypeScript) на стороне хоста, в пределах описанных контрактов.

2.2. **Закрытая часть (исполняемые модули)**

Существует закрытая проприетарная реализация, поставляемая в виде шифрованных исполнимых модулей/блобов. В её состав входят:

* реализация ядра **ZeroBus Run Kernel (ZRK)**;
* системные HOST-примитивы и драйверы (I/O, сетевые, криптографические и др.);
* примитивы WAL (журнал узла) и связанные с ними алгоритмы;
* примитивы UI (рендеринг, layout, виджеты, текст, темы), включая браузерный профиль.

2.3. **Версии и лицензии узла ZeroBus**

* Закрытая реализация присутствует в сборке узла `zb`.
* В **community-версии**:

  * часть примитивов недоступна, либо реализована в базовом (неоптимизированном) варианте;
  * UI-примитивы и клиентская часть могут отсутствовать или быть ограничены.
* Для использования оптимизированных алгоритмов (ускоренные индексы, ANN, скетчи, WAL) и клиентских UI-примитивов (браузерный/нативный рендер) требуется **лицензионный грант** (премиум-функциональность).

2.4. **Роль ZDK**

* ZDK определяет **стабильный внешний контракт**, по которому:

  * закрытые модули должны себя вести;
  * открытые и сторонние реализации могут быть подключены.
* ЗDK **не различает** community и premium с точки зрения API: различается только набор доступных KindId и качество/сложность внутренних алгоритмов.

---

## 3. Архитектурная модель ZDK относительно ZRK

3.1. **Форма исполнения ядра ZRK**

* Ядро ZRK существует в двух основных исполнениях:

  * **нативный Rust-бинарь**;
  * **WASM-модуль**, пригодный для запуска в браузере или встроенной среде.
* Оба исполнения рассматриваются как **чёрный ящик**, реализующий ZRK-спеку и поддерживающий ZDK-контракты.

3.2. **Размещение ядра относительно хоста**

* ZRK **всегда исполняется рядом** с хост-приложением:

  * в отдельном процессе (узел ZeroBus);
  * либо в отдельном треде внутри того же процесса (встраиваемый режим);
  * либо в отдельном WASM-контейнере (браузер/встраиваемая платформа).
* Во всех вариантах размещения выполнение ZRK считается **изолированным**, а хост и ядро общаются через формализованный шлюз.

3.3. **Единственный канал взаимодействия: HOST-шлюз**

3.3.1. Взаимодействие хост-процесса с ядром ZRK осуществляется **только** через плоскость `HOST`.

Любые операции уровня `TASK`, `EMIT`, `SCAN` доступны хосту исключительно как команды, инкапсулированные в запросы к HOST-шлюзу.

3.3.2. На уровне ZDK это выражается в виде абстракции:

> **Host Gateway** — минимальная функция/точка входа ядра, принимающая бинарный запрос и возвращающая бинарный ответ, интерпретацию которых задаёт ZDK.

Конкретная сигнатура и детализация wire-формата зависят от языка/платформы, но логически:

* каждый запрос описывает:

  * идентификатор целевого `RunId`;
  * тип операции (класс/семейство/вариант, действие);
  * бинарные параметры;
* каждый ответ описывает:

  * результат действия;
  * возможные выходные данные;
  * изменения состояния (через стандартные механизмы ZRK).

3.3.3. Даже при линковке ZRK как Rust-библиотеки к тому же бинарнику, где живёт бизнес-код, **прямые вызовы внутренних функций ядра запрещены**.

Хост-код обязан обращаться к ядру только через:

* Host Gateway (встроенный FFI/ABI-шлюз);
* и, соответственно, только через семантику классов/семейств/примитивов, описанную в ZDK.

3.4. **Роль ZDK в этой модели**

ZDK фиксирует:

* какие классы и семейства примитивов существуют;
* какие KindId за ними закреплены;
* какой **смысл** у операций над этими примитивами, инициируемых через Host Gateway;
* какие наборы примитивов входят в различные профили (Core/UI/Web).

ZDK **не определяет**, как именно ядро реализует эти операции внутри, но требует соблюдения описанных инвариантов и семантики.

---

## 4. KindId: идентификатор примитива

4.1. **Структура KindId**

Каждый примитив ZeroBus, доступный через ZDK, имеет 32-битный идентификатор:

```text
KindId = (class << 24) | (family << 16) | variant
```

где:

* `class`  (8 бит, старшие)   — крупный класс сущностей;
* `family` (8 бит, средние)   — семейство внутри класса;
* `variant` (16 бит, младшие) — конкретный вариант/алгоритм/драйвер.

4.2. **Инварианты KindId**

4.2.1. Для всех зарегистрированных примитивов в рамках ZDK v1:

* комбинация `(class, family, variant)` уникальна;
* значения `class` и `family` фиксированы данной спецификацией;
* значения `variant` могут иметь зарезервированные диапазоны для:

  * базовых реализаций (0x0001–0x0FFF);
  * оптимизированных/премиум (0x1000–0x1FFF);
  * пользовательских расширений (0x8000–0xFFFF).

4.2.2. Реестр KindId ведётся как часть артефактов ZDK и расширяется совместимо:

* добавление новых KindId допускается;
* изменение семантики существующего KindId требует повышения major-версии ZDK.

4.2.3. Ядро ZRK рассматривает KindId как опаковое значение; его внутреннее разбор/маршрутизация зависят от реализации, но должны сохранять поведение, описанное для данного KindId в ZDK.

---

## 5. Классы и семейства ZDK v1

В данном разделе фиксируются классы (`class`) и семейства (`family`) примитивов, входящих в ZDK v1.

Перечисления вариантов (`variant`) являются частью реестра KindId и могут уточняться/расширяться в отдельных каталогах (например, `algorithms`, `drivers`, `ui`), при сохранении общей структуры.

### 5.1. Класс 0x01 — HOST_DEV

**Назначение:** драйверы среды, транспортов и хранилищ, с которыми ядро ZRK взаимодействует через плоскость `HOST` и которые экспонируются хост-коду через ZDK.

#### 5.1.1. Семейство 0x01 — STREAM

Потоковые драйверы (байтовые потоки, сообщения, сигналы):

* `KindId(0x01, 0x01, 0x0001)` — `stream.inproc`
  Внутрипроцессный поток (каналы между run-ами в том же процессе).

* `... 0x0002` — `stream.ipc`
  Межпроцессный поток (локальные сокеты, pipe, shm-транспорт).

* `... 0x0003` — `stream.tcp`
  TCP-соединения.

* `... 0x0004` — `stream.udp`.

* `... 0x0005` — `stream.quic`.

* `... 0x0006` — `stream.ws`
  WebSocket потоки.

* `... 0x0007` — `stream.mqtt`.

* `... 0x0008` — `stream.kafka`.

* `... 0x0009` — `stream.rng_hw`
  Поток криптографически стойких случайных байтов от аппаратного генератора.

* `... 0x000A` — `stream.rng_sw`
  Поток псевдослучайных байтов от детерминированного генератора (управляемый seed).

* `... 0x000B` — `stream.clock`
  Поток отметок времени (тикеры/таймеры).

* `... 0x000C` — `stream.task`
  Поток событий/состояний run-ов (очереди задач, статусы).

**Назначение на уровне ZDK:**
Каждый такой KindId задаёт тип порта/канала, который создаётся и конфигурируется через Host Gateway, и поверх которого ZRK организует I/O: приём/отправку сообщений, генерацию событий, обратные нотификации.

#### 5.1.2. Семейство 0x02 — BLOCK

Блочные драйверы:

* `KindId(0x01, 0x02, 0x0001)` — `block.file`
  Работа с файлами файловой системы хоста.

* `... 0x0002` — `block.device`
  Сырые блочные устройства (диски, разделы).

* `... 0x0003` — `block.memory`
  In-memory области, работающие как блочное устройство (арены, временные буферы).

ZDK фиксирует только **классификацию**. Конкретные операции (open/close/resize/fsync) реализуются через команды Host Gateway, привязанные к этим KindId.

#### 5.1.3. Семейство 0x03 — BLOB

Объектные и key–value хранилища:

* `KindId(0x01, 0x03, 0x0001)` — `blob.ram`
  Оперативное KV-хранилище.

* `... 0x0002` — `blob.fs`
  KV поверх файловой системы (каталог + файлы).

* `... 0x0003` — `blob.s3`
  S3-совместимое объектное хранилище.

* `... 0x0004` — `blob.redis`
  Сетевое KV-хранилище вида Redis.

* `... 0x0005` — `blob.grant`
  Хранилище грантов/политик доступа.

* `... 0x0006` — `blob.id`
  Хранилище идентичностей/ключей.

* `... 0x0007` — `blob.timer`
  Хранилище описаний таймеров и отложенных событий.

BLOB-примитивы используются ядром для хранения метаданных, политик и служебных записей; ZDK описывает лишь их типы и назначение.

#### 5.1.4. Семейство 0x10 — UI_INPUT (браузерный/нативный профиль)

Потоки событий ввода:

* `KindId(0x01, 0x10, 0x0001)` — `ui.input.keyboard`.
* `... 0x0002` — `ui.input.pointer`.
* `... 0x0003` — `ui.input.wheel`.
* `... 0x0004` — `ui.input.gamepad`.
* `... 0x0005` — `ui.input.sensor`.

Эти KindId используются в UI-профиле для описания источников событий. Реализация (браузер/нативный UI-движок) преобразует события платформы в потоки, видимые ядру.

#### 5.1.5. Семейство 0x11 — UI_SURFACE

Поверхности рендеринга:

* `KindId(0x01, 0x11, 0x0001)` — `ui.surface.main`.
* `... 0x0002` — `ui.surface.overlay`.
* `... 0x0003` — `ui.surface.offscreen`.

Каждая поверхность связывается с конкретным бэкендом (Canvas/WebGL/WebGPU/нативный GPU) и принимает кадры для отрисовки от UI-алгоритмов (см. класс STATE_ALGO).

#### 5.1.6. Семейство 0x12 — UI_MEDIA

Медиадрайверы:

* `ui.media.audio_out`,
* `ui.media.audio_in`,
* `ui.media.video_in`.

Используются для потоков аудио/видео, в том числе из/в браузерные API.

#### 5.1.7. Семейство 0x13 — STORAGE_WEB

Web-хранилища:

* `KindId(0x01, 0x13, 0x0001)` — `storage.web.local` (localStorage).
* `... 0x0002` — `storage.web.session` (sessionStorage).
* `... 0x0003` — `storage.web.idb` (IndexedDB).

ZDK фиксирует факт их существования и назначение; конкретная сериализация ключей/значений определяется профилем ZDK.Web.

---

### 5.2. Класс 0x02 — STATE_ALGO

**Назначение:** алгоритмические примитивы состояния (индексы, скетчи, CRDT, UI-состояние и т.п.), которыми ядро оперирует через плоскости `EMIT` и `SCAN`.

ZDK описывает их как KindId с семействами и вариантами.

#### 5.2.1. Семейство 0x01 — INDEX

Индексирующие структуры:

* `index.hash`        — hash-словарь.
* `index.btree`       — B-дерево/упорядоченный индекс.
* `index.roaring`     — bitmap-индексы (Roaring).
* `index.trigram`     — 3-граммный индекс строк.
* `index.interval`    — интервальные индексы.
* `index.zone_map`    — zone map по блокам.
* `index.bloom`       — фильтры принадлежности.
* `index.label_map`   — label → ids.
* `index.fm_index`    — компактный полнотекстовый индекс (FM).
* `index.string_dict` — словарь строк → id.
* `index.cuckoo`      — Cuckoo hash.
* `index.quotient`    — Quotient filter.
* `index.bloomier`    — ассоциативный массив на bloomier-структуре.

Для каждого варианта закреплён свой `variant` в рамках `class=0x02, family=0x01`.

#### 5.2.2. Семейства 0x02–0x0E — ALGOS

* `family = 0x02` — **SKETCH**
  (count-min, count-sketch, top-K и т.п.)

* `family = 0x03` — **DISTINCT**
  (HyperLogLog, KMV, theta-sketch).

* `family = 0x04` — **QUANTILE**
  (гистограммы, t-digest, DDSketch, GK, summary-перцентили).

* `family = 0x05` — **WINDOW**
  (экспоненциальные окна, EWMA, reservoir sampling).

* `family = 0x06` — **TEXT**
  (aho-corasick, FST-терм словарь).

* `family = 0x07` — **SIMILARITY**
  (minhash, simhash, обобщённые LSH).

* `family = 0x08` — **ANN**
  (HNSW, IVF-PQ, OPQ и др.).

* `family = 0x09` — **SPATIAL**
  (R-деревья, KD-деревья,*quadtree*, Z-order, Hilbert).

* `family = 0x0A` — **TIMESERIES**
  (segment tree, Fenwick).

* `family = 0x0B` — **GRAPH**
  (потоковый подсчёт треугольников, PageRank, HyperANF и др.).

* `family = 0x0C` — **LINALG**
  (Frequent Directions, random projection).

* `family = 0x0D` — **CRDT**
  (PN-счётчики, OR-множества, LWW-регистры, CRDT-карты).

* `family = 0x0E` — **RECON**
  (IBLT и подобные структуры для согласования множеств).

Каждый конкретный алгоритм в этих семействах получает свой `variant`. Детализация (контракты `emit.reduce`/`emit.converge`/`scan.*`) фиксируется в отдельном каталоге алгоритмов ZDK.

#### 5.2.3. Семейство 0x10 — WAL

* `KindId(0x02, 0x10, 0x0001)` — `wal.segmented`
  Абстракция сегментированного журнала узла.

ZDK фиксирует только логический факт: существует семейство WAL-примитивов, через которые реализуется `emit.commit` и чтение журнала. Конкретная реализация (премиум/бесплатная) скрыта внутри закрытого модуля.

#### 5.2.4. Семейства 0x20–0x24 — UI-алгоритмы (профиль ZDK.UI)

UI-семейства принадлежат классу STATE_ALGO, так как они описывают чистое состояние и команды рендера, а не I/O-драйверы.

* `family = 0x20` — **UI_FRAME2D**

  * `KindId(0x02, 0x20, 0x0001)` — `ui.frame2d.cmd_stream`
    Буфер команд 2D-рендера (IMGUI-подобная модель): последовательность команд `BeginFrame/EndFrame`, `DrawRect`, `DrawImage`, `DrawTextRun`, `PushClip/PopClip`, `PushTransform/PopTransform` и т.д.

* `family = 0x21` — **UI_LAYOUT**

  Алгоритмы layout’а (stack/flex/grid):

  * дерево элементов, их constraints;
  * результаты раскладки (прямоугольники, z-order).

* `family = 0x22` — **UI_WIDGET**

  Состояние виджетов:

  * фокусы, hover, active;
  * маршрутизация событий ввода (hit-testing, capture).

* `family = 0x23` — **UI_TEXT**

  Алгоритмы шейпинга текста, кеш глифов, разбивки на строки.

* `family = 0x24` — **UI_THEME**

  Темы/стили:

  * палитры цветов;
  * размеры и отступы;
  * декоративные параметры.

Эти семейства образуют минимальный набор для построения полностью событийно-ориентированного UI поверх ZRK, без прямой зависимости от DOM/HTML/CSS.

---

### 5.3. Класс 0x03 — SCAN_META

**Назначение:** метаданные источников, режимов и форм результатов сканирования.

ZDK фиксирует:

* **источники** (WAL, алгоритмы, порты HOST, гранты);
* **режимы** (SEQ/RANGE/PREFIX/POINT/KNN/BITMAP/AGG);
* **формы результата** (offset_len, tagged, scalar).

Конкретные значения `family`/`variant` для SCAN_META закрепляются в отдельном каталоге при реализации сканеров и не дублируют факты, уже описанные в ZRK; ZDK здесь фиксирует только тот факт, что такая группировка существует и используется во всех SDK.

---

## 6. Модель работы ZDK с примитивами

6.1. **Общая идея**

С точки зрения хост-разработчика ZDK предоставляет:

* **типизированный API**, опирающийся на KindId и профили;
* **сильную типизацию конфигураций** (структуры под каждый KindId);
* **унифицированные вызовы** к Host Gateway, скрывающие бинарный протокол.

Всё, что происходит дальше, — внутренняя работа ZRK.

6.2. **Хост-обвязки (языковые SDK)**

Для каждого поддерживаемого языка ZDK предоставляет:

* тип `KindId` и перечисления для известных классов/семейств/вариантов;
* структуры конфигураций (например, `StreamConfig`, `BlobConfig`, `IndexConfig`, `UiFrame2dConfig`);
* типы запросов/ответов Host Gateway:

  * «создать/закрыть/переконфигурировать примитив»;
  * «инициировать run»;
  * «выполнить шаг emit/scan» и т.п.

SDK **не раскрывает** внутренних типов ядра ZRK, а работает на уровне этих структур и KindId.

6.3. **Единый подход к взаимодействию**

Независимо от платформы:

* серверное приложение, использующее ZeroBus;
* утилита администратора/наблюдения;
* браузерное приложение (через WASM-ядро);
* встроенная система (через встраиваемый runtime ZRK);

— получают один и тот же логический API:

1. Выбрать KindId интересующего примитива.
2. Сформировать конфигурацию/запрос в структурах SDK.
3. Отправить запрос в Host Gateway (через ZDK-обёртку).
4. Обработать ответ, включая возможные изменения состояний/кодов (согласно ZRK).

---

## 7. Профили ZDK

### 7.1. Профиль `ZDK.Core`

Минимальный профиль, доступный в community-версии и достаточный для:

* записей в WAL;
* построения базовых индексов;
* работы с blob-хранилищами и потоками;

Включает:

* HOST_DEV:

  * `stream.inproc`, `stream.tcp/ws` (минимальный набор),
  * `block.file`,
  * `blob.ram`, `blob.fs`, базовый `blob.s3`/`blob.redis`.
* STATE_ALGO:

  * основные INDEX (hash/btree/roaring/bloom),
  * базовые скетчи (счётчики, HLL),
  * WAL.
* SCAN_META:

  * базовые источники и режимы (SEQ, RANGE, PREFIX, POINT, AGG).

Оптимизированные или продвинутые алгоритмы (ANN, сложные CRDT, продвинутые скетчи) могут относиться к premium, сохраняя те же KindId.

### 7.2. Профиль `ZDK.UI` (premium)

Расширяет `ZDK.Core`:

* HOST_DEV:

  * `ui.input.*`, `ui.surface.*`, `ui.media.*`, `storage.web.*`.
* STATE_ALGO:

  * `ui.frame2d.*`, `ui.layout.*`, `ui.widget.*`, `ui.text.*`, `ui.theme.*`.

Предназначен для построения интерфейсов пользователя (браузер/нативно) полностью на основе Run/KindId-модели. Реализации UI-примитивов и рендеринга относятся к закрытой части и активируются лицензионными грантами.

### 7.3. Профиль `ZDK.Web`

Конкретизация `ZDK.UI` для браузерной среды:

* ядро ZRK поставляется как WASM-модуль;
* JS-обвязка маппит Web APIs:

  * DOM-события → `ui.input.*`;
  * Canvas/WebGL/WebGPU → `ui.surface.*`;
  * WebAudio/getUserMedia → `ui.media.*`;
  * localStorage/sessionStorage/IndexedDB → `storage.web.*`.

С точки зрения ZDK, это лишь конкретный носитель для тех же KindId и тех же логических примитивов.

---

## 8. Расширяемость и совместимость

8.1. **Добавление новых примитивов**

* Новые KindId могут добавляться:

  * в существующие классы/семейства;
  * в новые классы/семейства, добавленные ZDK v1.x.
* При этом необходимо:

  * не переиспользовать уже занятые `(class, family, variant)`;
  * описать семантику нового примитива в терминах ZRK и Host Gateway.

8.2. **Изменение существующих примитивов**

* Изменение семантики уже выпущенного KindId (поведение, контракт, тип конфигурации) требует:

  * объявления новой major-версии ZDK (v2 и далее);
  * либо выделения нового KindId, если необходима параллельная поддержка старого и нового поведения.

8.3. **Сторонние расширения**

* Пользовательские/партнёрские реализации могут использовать зарезервированные диапазоны `variant` (например, `0x8000+`) внутри существующих `class`/`family`.
* Такие расширения не должны конфликтовать с официальным реестром ZDK и обязаны соблюдать базовые инварианты ZRK.

---

Эта спецификация ZDK v1 фиксирует:

* как ZRK-ядро встраивается в окружение (только рядом, только через HOST);
* как все примитивы ZeroBus классифицируются в терминах KindId;
* какие профили и наборы примитивов доступны в открытом и премиум-режимах.

Всё остальное — уже вопрос реализации, производительности и красоты, но геометрия системы от этого не меняется.
