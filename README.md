# ZeroBus Development Kit (ZDK)

**ZeroBus — это не «ещё одна очередь».  
ZDK - Это открытый каталог примитивов для микроядерной распределённой ОС поверх событий и состояния.**

На базе ZeroBus можно строить:

- шины событий и CQRS-платформы;
- финансовые реестры и «умные» книги учёта;
- оркестраторы процессов и serverless-рантаймы;
- игровые бекенды и мультиагентные системы;
- UI и целые рабочие столы прямо в браузере на той же архитектуре.
- или собрать систему мониторинга и управлением производственным предприятием с роем IoT
---

## 1. Что это такое

**ZeroBus Run Kernel (ZRK)** — это формально определённое ядро, которое управляет единицей работы `run`:

- у каждого `run` есть строгое состояние (`INIT → WAIT → EXEC → DONE`);
- есть четыре ортогональных пространства исполнения:
  - `HOST` — системное, драйверы и расписание;
  - `EMIT` — запись событий;
  - `SCAN` — чтение и вычисление представлений;
  - `TASK` — бизнес-логика (WASM, бинарь и т.п.);
- есть формальная модель ошибок, детерминизма и реплея.

**ZeroBus Development Kit (ZDK)** — это:

- открытый **каталог классов/семейств/примитивов** (KindId);
- единый способ описывать драйверы, индексы, UI-движки и т.д.;
- SDK-обвязки для хост-языков (Rust/Go/TS), которые общаются с ядром **только через HOST**.

Проще говоря:

> ZDK + ZRK = маленькая операционная система для событий и состояния,  
> которую можно запускать в кластере, в отдельном процессе или прямо в браузере в виде WASM.

---

## 2. Чем это отличается от всего остального

### Не просто очередь

Обычная очередь / брокер сообщений:

- знает про «сообщения» и, максимум, про топики/партиции;
- всё остальное — дело десятка разных сервисов и баз.

ZRK+ZDK:

- знают про **run** как логическую задачу с формальным жизненным циклом;
- пишут в WAL через `EMIT` и читают через `SCAN`;
- обеспечивают детерминизм, реплей и восстановление состояния по журналу;
- задают общую модель для **всех** подсистем: логика, хранение, аналитика, UI.

### Не конкурент Kubernetes, а слой выше

- Kubernetes оркестрирует **контейнеры / процессы**.
- ZRK оркестрирует **run-ы** как логические единицы работы.
- ZDK описывает, **какие именно примитивы** эти run-ы используют: индексы, потоки, UI, драйверы.

Можно:

- запускать ZRK внутри подов k8s как **application-level control plane**;
- или строить «ZeroBus-облако», где k8s — внутренняя деталь, а логика стандартизована на уровне run/EMIT/SCAN.

### Не блокчейн, но почти идеальное ядро для него

- EMIT — это «журнал транзакций»;
- `emit.reduce` — детерминированный переход состояния по событию;
- `emit.converge` — слияние состояний (CRDT, шардирование, rollups);
- `scan.seal` — «снимок состояния на высоте N».

Сверху добавляются:

- консенсус,
- сетевая модель,
- экономика.

И получается **ядро для ledgers / rollup-фреймворков / permissioned chains**.

---

## 3. Ключевые идеи ZDK

### 3.1. Формальное ядро ZRK

В отдельной спецификации `spec/zrk.v1.ru.md` зафиксированы:

- единица работы: `RunId`, родитель/потомки;
- строгая машина состояний `INIT → WAIT → EXEC → DONE`;
- коды завершения: `unset`, `panic`, `invalid`, `rejected`;
- четыре пространства `HOST/EMIT/SCAN/TASK`;
- минимальный ABI: `task.*`, `host.*`, `emit.*`, `scan.*`;
- инварианты детерминизма, асинхронности и изоляции.

Это математическое ядро, не завязанное на конкретный язык или протокол.

### 3.2. Каталог примитивов (ZDK)

В `spec/zdk.v1.ru.md` описывается:

- **KindId (32 бита)**: `class | family | variant`:
  - `class` — крупный класс сущностей (драйверы, алгоритмы, UI, WAL…);
  - `family` — семейство (индексы, скетчи, spatial, UI-layout и т.п.);
  - `variant` — конкретный алгоритм/драйвер.
- классы и семейства:
  - драйверы среды (`STREAM`, `BLOCK`, `BLOB`, web-storage, UI-input/media/surface);
  - алгоритмы состояния (`INDEX`, `SKETCH`, `CRDT`, `ANN`, `GRAPH`, `WAL`, `UI_*`);
- профили:
  - **ZDK.Core** — ядро шины/платформы;
  - **ZDK.UI** — набор для построения UI поверх run-ядра;
  - **ZDK.Web** — браузерный профиль (WASM + JS-драйверы).

### 3.3. Единый HOST-шлюз

Важный принцип:

> Даже если ядро ZRK линковано как Rust-библиотека —  
> хост-код не имеет права лазить внутрь. Всё общение только через единый HOST-шлюз.

Это даёт:

- одинаковую модель для «ядро в отдельном процессе», «ядро рядом в треде», «ядро в браузере в виде WASM»;
- безопасное обновление ядра без переписывания приложений;
- возможность поставлять закрытые оптимизированные модули, не ломая публичную спеку.

---

## 4. Что можно построить на ZDK (примерные сценарии)

Ниже — не маркетинг, а реальные классы задач, где такая геометрия особенно полезна.

### 4.1. CQRS / Event-Sourcing платформа

- EMIT — единственный способ записать событие.
- SCAN — единственный способ читать состояние.
- всё состояние — результат детерминированных `reduce/converge` по журналу.

Подходит для:

- бухгалтерии, биллинга, платёжных систем;
- CRM/ERP/логистики с тяжёлой аналитикой;
- систем, где **аудит и реплей** не просто «nice-to-have», а обязательны.

### 4.2. Оркестратор процессов и саг

- каждый бизнес-процесс = один или несколько run-ов;
- `WAIT` через `host.sync` пока ждём:
  - внешний callback,
  - одобрение,
  - таймер/дедлайн;
- EMIT логирует все шаги, ошибки, компенсации;
- SCAN даёт «где сейчас застрял мой процесс».

Альтернатива зоопарку из отдельных движков для:

- KYC/KYB;
- платежных пайплайнов;
- сложных цепочек поставок и документооборота.

### 4.3. Serverless-рантайм с памятью

- каждый вызов/сага = `run`;
- состояние живёт в EMIT/SCAN, функции в TASK остаются почти чистыми;
- HOST управляет:
  - лимитами,
  - частотой вызовов,
  - таймерами,
  - временем жизни.

Это даёт FaaS, который:

- умеет **строго упорядочивать** события;
- мгновенно переигрывать всё состояние;
- не тонет в ад-hoc базах и кэших вокруг функций.

### 4.4. Леджеры и финансовые ядра

- EMIT — журнал движений денег/активов;
- STATE_ALGO:
  - индексы по счетам/позиций;
  - риск-модели;
  - агрегаты по дню/месяцу/регулятору;
- SCAN — отчёты, позиции, лимиты, регуляторные выгрузки.

Ключевой бонус: формальная модель жизненного цикла `run` + детерминизм →  
проще добиться **корректности, аудируемости и воспроизводимости**, чем на произвольном микросервисном зоопарке.

### 4.5. Игровые бекенды и виртуальные миры

- каждый матч/комната/шард = run (или группа run-ов);
- EMIT — входные действия игроков, события мира;
- STATE_ALGO — состояния мира, индексы объектов, spatial-структуры;
- SCAN — снапшоты для клиентов, повтор событий для античита;
- TASK — модульное игровое правило в WASM.

Получаем:

- **авторитетный сервер** с реплеем;
- time-travel-debugging;
- моддинговую архитектуру без «lua-спагетти».

### 4.6. IoT / Edge-fabric

На краю (edge):

- маленький экземпляр ZRK+ZDK.Core;
- драйверы для железа, датчиков, радиоинтерфейсов;
- EMIT хранит локальный журнал измерений;
- SCAN кормит локальные дашборды и ML-модели.

В центре:

- собираем журналы;
- агрегируем, пересчитываем, воспроизводим сценарии «как было бы, если».

---

### 4.7. Мультиагентные/LLM-системы

- каждый агент = run;
- EMIT журналирует:
  - все сообщения,
  - вызовы тулов,
  - принятые решения;
- SCAN строит:
  - дерево задачи,
  - состояние плана,
  - объяснимые отчёты;
- HOST ограничивает:
  - бюджеты,
  - время,
  - глубину рекурсий и фанатизм.

Это превращает LLM-«магический туман» в **строго определяемый процесс** с логами, реплеем и контролем.

### 4.8. UI и «микро-ОС» в браузере

Профиль ZDK.UI + ZDK.Web позволяет:

- запускать ядро ZRK как WASM в браузере;
- использовать JS только как:
  - видеодрайвер (`ui.surface.*` → Canvas/WebGL/WebGPU),
  - драйвер ввода (`ui.input.*`),
  - мост к Web APIs (storage, сеть);
- описывать интерфейс как набор run-ов, которые:
  - читают input-стримы,
  - EMIT’ят команды рисования,
  - SCAN’ят своё состояние.

В результате получается:

> не очередная SPA на React, а **маленькая микроядерная ОС внутри вкладки**,  
> где окна/панели/редакторы — просто run-ы на общей модели.

---

## 5. Кому это вообще нужно

- **Архитекторам**, которые устали от «зоопарка сервисов» и хотят одну, строго определённую модель:
  - как порождать работу,
  - как логировать,
  - как восстанавливать состояние,
  - как управлять ресурсами.

- **Разработчикам**, которые хотят:
  - писать бизнес-логику как чистые/почти чистые функции поверх событий и представлений;
  - а не разбирать каждый раз: чем это хранилище/брокер сегодня отличается от вчерашнего.

- **Бизнесу и продуктовым командам**, которым нужны:
  - надёжные леджеры;
  - воспроизводимые аналитические данные;
  - сложные процессы, которые можно объяснить и реконструировать постфактум.

- **Исследователям/экспериментаторам**, которым важно:
  - запускать новые алгоритмы на тех же данных;
  - сравнивать состояния «до» и «после»;
  - не бояться, что эксперимент «сломает боевую систему».

---

## 6. Открытое vs закрытое

- Всё, что описано в этом репозитории (`zdk/`), — **открыто и бесплатно**, лицензия **Apache 2.0**:
  - спецификация ядра: `spec/zrk.v1.ru.md`;
  - спецификация каталога: `spec/zdk.v1.ru.md`;
  - реестр KindId, описания классов и семейств;
  - SDK-обвязки и документация.

- Существует закрытая проприетарная реализация:
  - (опционально) оптимизированные алгоритмы индексов, ANN, скетчей и т.д.;
  - системные драйверы, WAL и UI-движки;
  - браузерный/нативный стек.

Она поставляется как шифрованные модули, но обязана **строго соблюдать** эту спеку.  
Разработчик всегда может:

- опираться только на открытый функционал;
- заменить часть закрытых модулей своими реализациями, не ломая архитектуру.

---

## 7. Как читать этот репозиторий

Рекомендуемый порядок:

1. **Ядро (обязательно):**  
   `spec/zrk.v1.ru.md` — формальная спецификация ZeroBus Run Kernel:
   - run, состояния, коды;
   - пространства `HOST/EMIT/SCAN/TASK`;
   - инварианты и формальное доказательство.

2. **Каталог примитивов (ZDK):**  
   `spec/zdk.v1.ru.md` — описание:
   - структуры KindId;
   - классов/семейств и профилей (Core/UI/Web);
   - роли HOST-шлюза и языковых SDK.

3. **Дальше**:
   - смотреть реестр известных KindId;
   - следить за появлением SDK (Rust/Go/TS);
   - подключать ZRK-реализацию (нативную или WASM) как чёрный ящик.

---

## 8. Статус и планы

На момент версии `v1.0.0`:

- зафиксирована формальная модель ядра (ZRK);
- зафиксирован каталог и структура примитивов (ZDK);
- модель изначально рассчитана на:
  - запуск в кластере,
  - запуск встраиваемо,
  - запуск в браузере через WASM.

Дальше вокруг этих двух спецификаций будут расти:

- реализации ядра;
- SDK для разных языков;
- примерные конфигурации под типичные сценарии (ledger, workflow, UI-студия и т.д.).

---

### Кратко

Если смотреть привычными глазами — это «шина» или «платформа для событий».

Если смотреть внимательнее — это **микроядерная ОС для событий и состояния**,  
с чёткой моделью процесса (`run`), памяти (`EMIT/SCAN`) и системных вызовов (`HOST`/`TASK`).

ZDK фиксирует форму и каталог того, что живёт внутри этой ОС.  
Дальше вопрос только в том, какое именно будущее вы хотите на ней собрать.
